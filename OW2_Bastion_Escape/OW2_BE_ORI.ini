设置
{
	主程序
	{
		描述: "<FGc236ccFF>Ramattra + Shambali Monastery added!\n<FGFFFFFFFF>Work together to sneak past the Bastion prison guards and reach the end of the map to escape as every hero, each time a little harder.\nBastion Escape 2/Prison Escape/CCTV, but fixed for OW2.\n\nCredits included in spawn room.\nVersion 1.2.1 (Jan 14th, 2023)"
		模式名称: "<FGed6516FF>OW2 Bastion Escape"
	}

	大厅
	{
		地图轮换: 完成比赛后
		比赛语音聊天: 启用
		玩家上限 队伍1: 10
		玩家上限 队伍2: 0
		观战者人数上限: 12
		返回大厅: 从不
		队列中的玩家可以加入: 是
	}

	模式
	{
		突击模式
		{
			启用地图
			{
				66号公路 0
				“地平线”月球基地 0
				努巴尼 0
				哈瓦那 0
				国王大道 0
				多拉多 0
				好莱坞 0
				巴黎 0
				帕拉伊苏 0
				暴雪世界 0
				沃斯卡娅工业区 0
				渣客镇 0
				监测站：直布罗陀 0
				艾兴瓦尔德 0
				里阿尔托 0
				阿努比斯神殿 0
				香巴里寺院 0
			}
		}

		综合
		{
			复生时间: 20%
			急救包刷新时间: 20%
			敌方生命条: 关闭
			游戏模式开始: 手动
			英雄限制: 关闭
		}
	}

	英雄
	{
		队伍1
		{
			技能冷却时间: 30%

			堡垒
			{
				生命值: 150%
			}
		}

		队伍2
		{
			受到伤害量: 10%
			技能冷却时间: 0%
			生命值: 500%

			堡垒
			{
				无需装弹: 开启
				生命值: 500%
			}
		}

		综合
		{
			战斗时终极技能充能速度: 0%
			无需装弹: 开启
			终极技能自动充能速度: 0%

			D.Va
			{
				推进器冷却时间: 125%
			}

			半藏
			{
				“跃”冷却时间: 60%
				音冷却时间: 0%
			}

			卡西迪
			{
				战术翻滚冷却时间: 50%
			}

			回声
			{
				飞行冷却时间: 33%
			}

			天使
			{
				守护天使冷却时间: 67%
			}

			奥丽莎
			{
				强固防御冷却时间: 50%
				标枪旋击冷却时间: 70%
			}

			安娜
			{
				麻醉镖冷却时间: 67%
			}

			巴蒂斯特
			{
				受到治疗量: 50%
				弹道速度: 500%
				投射物重力: 0%
				生命值: 25%
				维生力场冷却时间: 20%
			}

			布丽吉塔
			{
				屏障护盾充能速度: 500%
				能量盾击冷却时间: 120%
			}

			托比昂
			{
				可用武器: 仅限锻造锤
				热力过载冷却时间: 20%
				热力过载持续时间: 40%
				部署炮台: 关闭
			}

			末日铁拳
			{
				悍猛格挡冷却时间: 50%
				火箭重拳冷却时间: 80%
				裂地重拳冷却时间: 80%
			}

			查莉娅
			{
				垂直跳跃速度: 140%
				粒子屏障冷却时间: 60%
				粒子炮辅助攻击击退倍率: 200%
			}

			温斯顿
			{
				喷射背包冷却时间: 80%
				屏障发射器冷却时间: 83%
			}

			源氏
			{
				闪冷却时间: 75%
			}

			猎空
			{
				闪回冷却时间: 50%
				闪现冷却时间: 50%
			}

			破坏球
			{
				动力铁球始终激活: 开启
			}

			禅雅塔
			{
				乱: 关闭
				治疗量: 200%
				生命值: 150%
			}

			秩序之光
			{
				传送面板冷却时间: 50%
				哨戒炮: 关闭
			}

			美
			{
				冰墙冷却时间: 67%
			}

			艾什
			{
				延时雷管冷却时间: 50%
				短筒猎枪冷却时间: 40%
			}

			莫伊拉
			{
				消散冷却时间: 50%
				生化之球治疗最大值: 500%
			}

			莱因哈特
			{
				冲锋冷却时间: 75%
			}

			西格玛
			{
				动能俘获冷却时间: 75%
				实验屏障冷却时间: 50%
				质量吸附冷却时间: 50%
			}

			路霸
			{
				拴猪圈冷却时间: 50%
			}

			黑影
			{
				位移传动冷却时间: 0%
			}
		}
	}

	扩展
	{
		生成更多机器人
	}
}

变量
{
	全局:
		0: bastionPosition
		1: heroRingPosition
		2: resetPosition
		3: creditsPosition
		4: endPosition
		5: heroList
		6: missingHeroes
		7: maxDeath
		8: I
		9: kills
		10: bastionBotTargetPrefer
		11: difficulty
		12: scoreboardArray
		13: firstPlace
		14: secondPlace
		15: thirdPlace
		16: textIDs
		17: savedIndex
		18: savedHero
		19: savedDeaths
		20: savedIsWinner
		21: savedSkipCount
		22: devList
		23: __currentMap__
		127: antiCrashActivated

	玩家:
		0: heroNumber
		1: progressionDeathCount
		2: skipCount
		3: isWinner
		4: invis
		5: anaSleepLimit
		6: temp
		7: attacker
		8: I
		9: target
		10: aimPosition
		11: turnSpeed
		12: tempAimPosition
		13: nearestTargetOutOfLoS
		14: dvaStart
		15: healID
		16: isInPosition
		17: rainbowOff
		18: runDeathCount
}

子程序
{
	0: savePlayerData
	1: progressHero
}

规则("OverPy Map Detection")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		If(数组包含(数组(地图(阿育陀耶), 地图(黑森林), 地图(黑森林), 地图(暴雪世界), 地图(暴雪世界), 地图(釜山), 地图(釜山), 地图(釜山), 地图(城堡), 地图(吉拉德堡), 地图(吉拉德堡), 地图(皇家赛道), 地图(斗兽场),
			地图(多拉多), 地图(生态监测站：南极洲), 地图(生态监测站：南极洲), 地图(艾兴瓦尔德), 地图(艾兴瓦尔德), 地图(埃斯佩兰萨), 地图(花村), 地图(花村), 地图(哈瓦那), 地图(好莱坞), 地图(好莱坞), 地图(
			“地平线”月球基地), 地图(伊利奥斯), 地图(伊利奥斯), 地图(伊利奥斯), 地图(伊利奥斯), 地图(怪鼠复仇), 地图(渣客镇), 地图(铁坂), 地图(国王大道), 地图(国王大道), 地图(漓江塔控制中心), 地图(漓江塔控制中心),
			地图(漓江塔庭院), 地图(漓江塔庭院), 地图(漓江塔夜市), 地图(漓江塔夜市), 地图(漓江塔), 地图(漓江塔), 地图(马莱温多), 地图(中城), 地图(墓园), 地图(尼泊尔), 地图(尼泊尔), 地图(尼泊尔), 地图(尼泊尔), 地图(
			尼泊尔), 地图(新皇后街), 地图(努巴尼), 地图(绿洲城), 地图(绿洲城), 地图(绿洲城), 地图(绿洲城), 地图(帕拉伊苏), 地图(巴黎), 地图(佩特拉), 地图(训练靶场), 地图(里阿尔托), 地图(66号公路), 地图(
			阿努比斯神殿), 地图(沃斯卡娅工业区), 地图(监测站：直布罗陀), 地图(地图工坊室内), 地图(地图工坊空地), 地图(地图工坊空地), 地图(地图工坊绿幕), 地图(地图工坊岛屿), 地图(地图工坊岛屿), 地图(香巴里寺院)), 当前地图));
			全局.__currentMap__ = 当前地图;
			中止;
		End;
		全局.__currentMap__ = 射线命中位置(矢量(500, 100, 500), 矢量(-500, -100, -500), 空, 空, 假);
		If(全局.__currentMap__ == 矢量(0, 0, 0) || 全局.__currentMap__ == 矢量(-500, -100, -500));
			全局.__currentMap__ = 射线命中位置(矢量(30, 5, 0), 矢量(-30, -10, -10), 空, 空, 假);
			If(全局.__currentMap__ == 矢量(-30, -10, -10));
				全局.__currentMap__ = 射线命中位置(矢量(200, 20, 100), 矢量(100, -100, -100), 空, 空, 假);
				If(全局.__currentMap__ == 矢量(100, -100, -100));
					全局.__currentMap__ = 射线命中位置(矢量(300, 20, -100), 矢量(300, -100, 100), 空, 空, 假);
					If(全局.__currentMap__ == 矢量(300, -100, 100));
						全局.__currentMap__ = 射线命中位置(矢量(50, 100, -150), 矢量(-50, -100, -160), 空, 空, 假);
						If(全局.__currentMap__ == 矢量(-50, -100, -160));
							全局.__currentMap__ = 射线命中位置(矢量(0, 300, 340), 矢量(0, -100, -300), 空, 空, 假);
							If(全局.__currentMap__ == 矢量(0, -100, -300));
								全局.__currentMap__ = 射线命中位置(矢量(140, 10, -240), 矢量(200, -10, -300), 空, 空, 假);
								If(全局.__currentMap__ == 矢量(200, -10, -300));
									全局.__currentMap__ = 射线命中位置(矢量(-180, 30, 60), 矢量(-180, -50, -60), 空, 空, 假);
								End;
							End;
						End;
					End;
				End;
			End;
		End;
		全局.__currentMap__ = 100 * 取整(Y方向分量(全局.__currentMap__), 上) + 10 * 取整(X方向分量(全局.__currentMap__), 至最近) + 取整(Z方向分量(全局.__currentMap__),
			下);
		If(全局.__currentMap__ == 10121);
			全局.__currentMap__ = 射线命中位置(矢量(-60, 20, -60), 矢量(60, -10, 60), 空, 空, 假);
			If(全局.__currentMap__ == 矢量(60, -10, 60));
				全局.__currentMap__ = 射线命中位置(矢量(-180, -70, 60), 矢量(-180, -100, -60), 空, 空, 假);
			End;
			全局.__currentMap__ = 100 * 取整(Y方向分量(全局.__currentMap__), 上) + 10 * 取整(X方向分量(全局.__currentMap__), 至最近) + 取整(Z方向分量(全局.__currentMap__),
				下);
		End;
	}
}

规则("Initialize global variables")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.maxDeath = 5;
		全局.bastionBotTargetPrefer = 地图工坊设置组合(自定义字符串("Game"), 自定义字符串("Bastion Bot Target Prefer System"), 0, 数组(自定义字符串("Dynamic"), 自定义字符串(
			"Nearest"), 自定义字符串("Lowest Health")), 0);
		全局.difficulty = 地图工坊设置组合(自定义字符串("Game"), 自定义字符串("Difficulty"), 1, 数组(自定义字符串("Easy"), 自定义字符串("Normal"), 自定义字符串("Hard"), 自定义字符串(
			"Expert"), 自定义字符串("Legendary")), 0);
		全局.savedIndex = 空数组;
		全局.savedHero = 空数组;
		全局.savedDeaths = 空数组;
		全局.savedIsWinner = 空数组;
		全局.savedSkipCount = 空数组;
		全局.devList = 数组(自定义字符串("EfeDursun125"), 自定义字符串("WOBBLYOW"), 自定义字符串("NOTBANANA"), 自定义字符串("REYDI"), 自定义字符串("DATZENYAT"), 自定义字符串(
			"PirateBoot"), 自定义字符串("BearWhoLived"));
	}
}

规则("save player data if the player has pa﻿ssed round 2")
{
	事件
	{
		子程序;
		savePlayerData;
	}

	动作
	{
		等待(服务器负载 / 100 * 0.500, 无视条件);
		If(事件玩家.heroNumber > 2);
			"We're saving data as a string, because although we can't hold entity id's, we can hold entity names as string."
			If(!数组包含(全局.savedIndex, 自定义字符串("{0}", 事件玩家)));
				修改全局变量(savedIndex, 添加至数组, 自定义字符串("{0}", 事件玩家));
			End;
			等待(服务器负载 / 100 * 0.500, 无视条件);
			全局.savedHero[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))] = 事件玩家.heroNumber;
			等待(服务器负载 / 100 * 0.500, 无视条件);
			全局.savedDeaths[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))] = 事件玩家.runDeathCount;
			等待(服务器负载 / 100 * 0.500, 无视条件);
			全局.savedIsWinner[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))] = 事件玩家.isWinner;
			等待(服务器负载 / 100 * 0.500, 无视条件);
			全局.savedSkipCount[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))] = 事件玩家.skipCount;
			小字体信息(事件玩家, 自定义字符串("your hero data is saved"));
			等待(2, 无视条件);
			小字体信息(事件玩家, 自定义字符串("if the match restarts, everyone's data will be lost!"));
		End;
	}
}

规则("add 1 to heroNumber, switch player to the newly unlocked hero, and set hero availability to that hero and all preceding")
{
	事件
	{
		子程序;
		progressHero;
	}

	动作
	{
		事件玩家.heroNumber += 1;
		小字体信息(所有玩家(所有队伍), 自定义字符串("{0} unlocked {1}", 事件玩家, 英雄图标字符串(全局.heroList[事件玩家.heroNumber])));
		播放效果(事件玩家, 状态爆炸声音, 颜色(白色), 所选位置(事件玩家), 200);
		事件玩家.progressionDeathCount = 0;
		等待(0.032, 无视条件);
		开始强制玩家选择英雄(事件玩家, 全局.heroList[事件玩家.heroNumber]);
		等待直到 (所用英雄(事件玩家) == 全局.heroList[事件玩家.heroNumber], 0.500);
		停止强制玩家选择英雄(事件玩家);
		等待(服务器负载 / 100 * 0.500, 无视条件);
		设置玩家可选的英雄(事件玩家, 数组分割(全局.heroList, 0, 事件玩家.heroNumber + 1));
		等待(服务器负载 / 100 * 0.500, 无视条件);
		预加载英雄(事件玩家, 数组(全局.heroList[事件玩家.heroNumber + 1], 全局.heroList[事件玩家.heroNumber + 1]));
		等待(服务器负载 / 100 * 0.500, 无视条件);
		等待(3, 无视条件);
		调用子程序(savePlayerData);
		等待(0.100, 无视条件);
	}
}

规则("map - b﻿lizzworld")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(全局.__currentMap__ == 地图(暴雪世界) || 全局.__currentMap__ == 1228) == 真;
	}

	动作
	{
		全局.bastionPosition[0] = 矢量(-121.979, 0.148, 110.507);
		全局.bastionPosition[1] = 矢量(-93.733, -1.047, 110.100);
		全局.bastionPosition[2] = 矢量(-66.733, 7.079, 110.571);
		全局.bastionPosition[3] = 矢量(-0.165, 7.421, 89.178);
		全局.bastionPosition[4] = 矢量(3.082, 3.900, 43.609);
		全局.bastionPosition[5] = 矢量(3.049, -4.850, 16.685);
		全局.endPosition = 矢量(2.772, -6.500, -6.900);
		全局.heroRingPosition = 矢量(-149.170, 0.830, 100.850);
		全局.resetPosition = 矢量(-150.250, 0.830, 104.510);
		全局.creditsPosition = 矢量(-170.800, 3.650, 96.450);
		开始强制重生室(队伍1, 2);
	}
}

规则("map - dorado")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(多拉多);
	}

	动作
	{
		全局.bastionPosition = 矢量(170.288, 19.100, 45.051);
		修改全局变量(bastionPosition, 添加至数组, 矢量(118.262, 18.250, 1.209));
		修改全局变量(bastionPosition, 添加至数组, 矢量(78.973, 17.480, -6.843));
		修改全局变量(bastionPosition, 添加至数组, 矢量(34.074, 11.080, -17.958));
		修改全局变量(bastionPosition, 添加至数组, 矢量(26.361, 10.650, 20.115));
		修改全局变量(bastionPosition, 添加至数组, 矢量(126.713, 16.300, 17.517));
		全局.endPosition = 矢量(16.012, 空数组, 5.874);
		全局.heroRingPosition = 矢量(182.470, 7.040, 42.270);
		全局.resetPosition = 矢量(183.300, 7.040, 37.960);
		全局.creditsPosition = 矢量(197.720, 10.010, 44.630);
		开始强制重生室(队伍1, 1);
	}
}

规则("map - eichenwalde")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(全局.__currentMap__ == 地图(艾兴瓦尔德) || 全局.__currentMap__ == 565) == 真;
	}

	动作
	{
		全局.bastionPosition[0] = 矢量(123.333, 8.971, -27.303);
		全局.bastionPosition[1] = 矢量(89.318, 21.095, -62.697);
		全局.bastionPosition[2] = 矢量(37.930, 12.620, -79.920);
		全局.bastionPosition[3] = 矢量(23.799, 7.417, -53.839);
		全局.bastionPosition[4] = 矢量(-4.858, 6.957, -31.559);
		全局.bastionPosition[5] = 矢量(25.587, 6.300, -14.531);
		全局.endPosition = 矢量(-10.354, -2.149, -12.399);
		全局.heroRingPosition = 矢量(131.335, 10.720, 1.098);
		全局.resetPosition = 矢量(128.060, 10.720, 1.840);
		全局.creditsPosition = 矢量(132.820, 13.720, 9.040);
		开始强制重生室(队伍1, 2);
	}
}

规则("map - havana")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(哈瓦那);
	}

	动作
	{
		全局.bastionPosition[0] = 矢量(117.332, 14.433, -58.091);
		全局.bastionPosition[1] = 矢量(140.438, 6.413, -16.667);
		全局.bastionPosition[2] = 矢量(31.288, 18.900, -75.331);
		全局.bastionPosition[3] = 矢量(-32.514, 7.150, -79.487);
		全局.bastionPosition[4] = 矢量(14.787, 7.300, -47.470);
		全局.bastionPosition[5] = 矢量(-71.110, 5.846, -72.362);
		全局.endPosition = 矢量(-71.203, 2, -50.678);
		全局.heroRingPosition = 矢量(158.256, 11, -47.739);
		全局.resetPosition = 矢量(158.300, 11, -44.350);
		全局.creditsPosition = 矢量(193.450, 13.250, -46.490);
		开始强制重生室(队伍1, 2);
	}
}

规则("map - hollywood")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(好莱坞);
	}

	动作
	{
		全局.bastionPosition[0] = 矢量(-26.166, 7.503, -134.609);
		全局.bastionPosition[1] = 矢量(-2.241, 12.161, -112.505);
		全局.bastionPosition[2] = 矢量(11.552, 6.303, -69.943);
		全局.bastionPosition[3] = 矢量(-7.480, 7.441, -43.441);
		全局.bastionPosition[4] = 矢量(-20.714, 8.050, 9.977);
		全局.bastionPosition[5] = 矢量(4.864, 7.147, 38.401);
		全局.endPosition = 矢量(-12.002, -1.307, 69.489);
		全局.heroRingPosition = 矢量(-27.291, 3.920, -156.654);
		全局.resetPosition = 矢量(-23.640, 3.920, -157.440);
		全局.creditsPosition = 矢量(-31.650, 8.960, -175.050);
		开始强制重生室(队伍1, 2);
	}
}

规则("map - horizon lunar colony")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(“地平线”月球基地);
	}

	动作
	{
		全局.bastionPosition[0] = 矢量(-15.287, 6, -127.244);
		全局.bastionPosition[1] = 矢量(16.250, 11.860, -106.756);
		全局.bastionPosition[2] = 矢量(64.269, 16, -74.726);
		全局.bastionPosition[3] = 矢量(33.705, 7.590, -41.578);
		全局.bastionPosition[4] = 矢量(19.496, 9, -1.439);
		全局.bastionPosition[5] = 矢量(66.687, 8.520, -37.241);
		全局.endPosition = 矢量(34.476, 12, -23.518);
		全局.heroRingPosition = 矢量(-41.390, 5, -159.030);
		全局.resetPosition = 矢量(-45.620, 5, -156.870);
		全局.creditsPosition = 矢量(-55.870, 7.680, -171.970);
		开始强制重生室(队伍1, 0);
	}
}

规则("map - junkerto﻿wn")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(渣客镇);
	}

	动作
	{
		全局.bastionPosition = 矢量(-96.235, 13.672, -136.725);
		修改全局变量(bastionPosition, 添加至数组, 矢量(-72.634, 6.669, -145.321));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-27.431, 13.480, -100.155));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-32.236, 12.976, -29.143));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-2.080, 11.366, -61.807));
		修改全局变量(bastionPosition, 添加至数组, 矢量(30.116, 13.407, -59.880));
		全局.endPosition = 矢量(30.248, 5.515, -81.733);
		全局.heroRingPosition = 矢量(-88.030, 11.220, -88);
		全局.resetPosition = 矢量(-103.910, 11.690, -86.600);
		全局.creditsPosition = 矢量(-92.710, 14.040, -73.790);
		开始强制重生室(队伍1, 2);
	}
}

规则("map - king's row")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(全局.__currentMap__ == 地图(国王大道) || 全局.__currentMap__ == 742) == 真;
	}

	动作
	{
		全局.bastionPosition = 矢量(-143.900, 7.130, 10.150);
		修改全局变量(bastionPosition, 添加至数组, 矢量(-120.990, 1.070, -12.080));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-91.380, 1.140, -27.900));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-55.460, -0.200, -29.830));
		修改全局变量(bastionPosition, 添加至数组, 矢量(5.980, 6.110, -30.350));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-21.560, 2.580, -8.160));
		全局.endPosition = 矢量(-1.900, 5, -0.290);
		全局.heroRingPosition = 矢量(-176.048, -0.070, 36.540);
		全局.resetPosition = 矢量(-175.230, -0.070, 43.030);
		全局.creditsPosition = 矢量(-185.560, 2.930, 38.320);
		开始强制重生室(队伍1, 1);
	}
}

规则("map - numbani")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(努巴尼);
	}

	动作
	{
		全局.bastionPosition[0] = 矢量(179.102, 4.250, 13.115);
		全局.bastionPosition[1] = 矢量(154.224, -4.180, 13.616);
		全局.bastionPosition[2] = 矢量(118.815, 4.250, 3.556);
		全局.bastionPosition[3] = 矢量(78.459, 6.250, -11.527);
		全局.bastionPosition[4] = 矢量(-49.872, 11.283, -43.701);
		全局.bastionPosition[5] = 矢量(7.964, 1.270, -6.488);
		全局.endPosition = 矢量(6.984, -1, 5.778);
		全局.heroRingPosition = 矢量(245.030, 0.200, 24.420);
		全局.resetPosition = 矢量(245.030, 0.200, 20.420);
		全局.creditsPosition = 矢量(254.540, 3.200, 22.870);
		开始强制重生室(队伍1, 1);
	}
}

规则("map - paraiso")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(帕拉伊苏);
	}

	动作
	{
		全局.bastionPosition = 空数组;
		修改全局变量(bastionPosition, 添加至数组, 矢量(-47.030, 6.860, -141.730));
		修改全局变量(bastionPosition, 添加至数组, 矢量(5.220, 12, -122));
		修改全局变量(bastionPosition, 添加至数组, 矢量(10.140, 3.900, -57.320));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-23.510, 10.110, -48.500));
		修改全局变量(bastionPosition, 添加至数组, 矢量(11.420, 5.100, -24.260));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-6.880, 0.500, 26.090));
		全局.endPosition = 矢量(-30.920, 3.300, 21.460);
		全局.heroRingPosition = 矢量(-78.250, 6.330, -167.960);
		全局.resetPosition = 矢量(-78.300, 5.030, -170.800);
		全局.creditsPosition = 矢量(-70.200, 7.750, -183.140);
		开始强制重生室(队伍1, 2);
	}
}

规则("map - paris")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(巴黎);
	}

	动作
	{
		全局.bastionPosition = 矢量(-95.984, 13.454, -83.535);
		修改全局变量(bastionPosition, 添加至数组, 矢量(-72.132, 11.976, -44.042));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-41.725, 13.990, -2.920));
		修改全局变量(bastionPosition, 添加至数组, 矢量(20, 10.030, -38.500));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-14.721, 14.250, -35.219));
		修改全局变量(bastionPosition, 添加至数组, 矢量(0.211, 10.174, -60.874));
		全局.endPosition = 矢量(9.563, 8.329, -59.980);
		全局.heroRingPosition = 矢量(-109.263, 15.300, -111.151);
		全局.resetPosition = 矢量(-115.030, 15.970, -122.820);
		全局.creditsPosition = 矢量(-119.740, 19, -132.450);
		开始强制重生室(队伍1, 1);
	}
}

规则("map - rialto")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(里阿尔托);
	}

	动作
	{
		全局.bastionPosition[0] = 矢量(-64.421, 5.040, -125.927);
		全局.bastionPosition[1] = 矢量(-16.976, 1.660, -38.459);
		全局.bastionPosition[2] = 矢量(-36.002, 4.750, -77.344);
		全局.bastionPosition[3] = 矢量(59.058, 0.070, -8.103);
		全局.bastionPosition[4] = 矢量(54.797, 1.740, -59.938);
		全局.bastionPosition[5] = 矢量(87.874, -0.370, 0.268);
		全局.endPosition = 矢量(98.662, -1.500, -21.009);
		全局.heroRingPosition = 矢量(-54.920, 3.750, -158.320);
		全局.resetPosition = 矢量(-59.050, 3.750, -158.410);
		全局.creditsPosition = 矢量(-57.060, 5.250, -181.510);
		开始强制重生室(队伍1, 2);
	}
}

规则("map - route 66")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(66号公路);
	}

	动作
	{
		全局.bastionPosition[0] = 矢量(-95.624, 12.660, -5.541);
		全局.bastionPosition[1] = 矢量(-38.680, 12.750, -22.136);
		全局.bastionPosition[2] = 矢量(-15.784, 8.540, -12.685);
		全局.bastionPosition[3] = 矢量(36.467, 2.140, -4.003);
		全局.bastionPosition[4] = 矢量(48.707, 10.110, 25.063);
		全局.bastionPosition[5] = 矢量(26.871, 7.010, 2.468);
		全局.endPosition = 矢量(47.956, 5.200, 47.318);
		全局.heroRingPosition = 矢量(-115.228, 5.799, -49.590);
		全局.resetPosition = 矢量(-115.010, 4.500, -46.010);
		全局.creditsPosition = 矢量(-113.270, 7.500, -63.140);
		开始强制重生室(队伍1, 1);
	}
}

规则("map - shambali monastery")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(香巴里寺院);
	}

	动作
	{
		全局.bastionPosition = 空数组;
		修改全局变量(bastionPosition, 添加至数组, 矢量(-37.100, 28.400, 192.320));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-13.270, 25.500, 146.040));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-57.820, 29, 122.100));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-18.190, 23.250, 88.510));
		修改全局变量(bastionPosition, 添加至数组, 矢量(11.100, 15.500, 40.100));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-16.060, 6.180, 12));
		全局.endPosition = 矢量(5.450, 9, 17.500);
		全局.heroRingPosition = 矢量(-7.690, 31.070, 226.970);
		全局.resetPosition = 矢量(-1.970, 31.070, 221.850);
		全局.creditsPosition = 矢量(1.750, 35, 232.500);
		开始强制重生室(队伍1, 2);
	}
}

规则("map - temple of anubis")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(阿努比斯神殿);
	}

	动作
	{
		全局.bastionPosition = 矢量(-17.188, 11.237, 105.646);
		修改全局变量(bastionPosition, 添加至数组, 矢量(-12.218, 10.667, 52.835));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-58.847, 6.810, 41.419));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-8.454, 1.153, 29.868));
		修改全局变量(bastionPosition, 添加至数组, 矢量(8.482, 4.898, 10.299));
		修改全局变量(bastionPosition, 添加至数组, 矢量(-23.218, 2.706, -26.863));
		全局.endPosition = 矢量(-0.866, -3.781, -10.919);
		全局.heroRingPosition = 矢量(-7.969, 4.701, 137.390);
		全局.resetPosition = 矢量(-17.160, 4.460, 137.760);
		全局.creditsPosition = 矢量(-11.300, 7.350, 149.110);
		开始强制重生室(队伍1, 1);
	}
}

规则("map - volskaya industries")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(沃斯卡娅工业区);
	}

	动作
	{
		全局.bastionPosition[0] = 矢量(-87.972, 2.020, 38.919);
		全局.bastionPosition[1] = 矢量(-67.835, 10.390, 49.479);
		全局.bastionPosition[2] = 矢量(-63.809, -0.410, 77.730);
		全局.bastionPosition[3] = 矢量(-11.250, 1.270, 76.356);
		全局.bastionPosition[4] = 矢量(-16.279, 2.200, 41.017);
		全局.bastionPosition[5] = 矢量(-6.364, 8.240, 35.514);
		全局.endPosition = 矢量(-11.477, -6, 19.868);
		全局.heroRingPosition = 矢量(-113.051, -1.980, 31.996);
		全局.resetPosition = 矢量(-115.180, -1.980, 35.240);
		全局.creditsPosition = 矢量(-128.250, 0.500, 24.750);
		开始强制重生室(队伍1, 0);
	}
}

规则("map - watchpoint gibraltar")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.__currentMap__ == 地图(监测站：直布罗陀);
	}

	动作
	{
		全局.bastionPosition[0] = 矢量(70.099, 9, 26.803);
		全局.bastionPosition[1] = 矢量(81.759, 6, 3.200);
		全局.bastionPosition[2] = 矢量(64.465, 9.690, -32.138);
		全局.bastionPosition[3] = 矢量(32.373, 3, -50.866);
		全局.bastionPosition[4] = 矢量(31.113, 7.300, -89.871);
		全局.bastionPosition[5] = 矢量(41.383, 4, -124.788);
		全局.endPosition = 矢量(46.558, 1, -146.808);
		全局.heroRingPosition = 矢量(80.213, -9.980, 46.632);
		全局.resetPosition = 矢量(75.310, -9.050, 38.500);
		全局.creditsPosition = 矢量(95.090, -6, 54.500);
		开始强制重生室(队伍1, 2);
	}
}

规则("bastion init position, unkillable status, and damage dealt scaling with difficulty setting")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		存活(事件玩家) == 真;
		已重生(事件玩家) == 真;
	}

	动作
	{
		等待(0.250, 无视条件);
		设置造成伤害(事件玩家, 100 + 50 * 全局.difficulty);
		传送(事件玩家, 全局.bastionPosition[栏位(事件玩家)]);
		If(!具有状态(事件玩家, 无法杀死));
			设置状态(事件玩家, 空, 无法杀死, 99999);
	}
}

规则("set hero list")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		"make default hero list, which includes all 36 heroes available in Season 2"
		全局.heroList = 数组(英雄(黑影), 英雄(死神), 英雄(莫伊拉), 英雄(雾子), 英雄(西格玛), 英雄(源氏), 英雄(奥丽莎), 英雄(秩序之光), 英雄(温斯顿), 英雄(D.Va), 英雄(猎空), 英雄(黑百合), 英雄(索杰恩),
			英雄(巴蒂斯特), 英雄(美), 英雄(回声), 英雄(布丽吉塔), 英雄(士兵：76), 英雄(破坏球), 英雄(卡西迪), 英雄(查莉娅), 英雄(卢西奥), 英雄(狂鼠), 英雄(法老之鹰), 英雄(天使), 英雄(莱因哈特), 英雄(半藏),
			英雄(末日铁拳), 英雄(路霸), 英雄(渣客女王), 英雄(艾什), 英雄(托比昂), 英雄(安娜), 英雄(禅雅塔), 英雄(堡垒));
		"remove all heroes that are not for some reason in Overwatch's list of all the heroes (at the time of making this, Mei is an example because she was removed to be patched)"
		修改全局变量(heroList, 根据值从数组中移除, 已过滤的数组(全局.heroList, !数组包含(全部英雄, 当前数组元素)));
		"add any heroes that for some reason are on Overwatch's list but not the game's (eg if I don't update the mode after a hero release). they are added as the second hero in the list"
		If(对任意为“真”(全部英雄, !数组包含(全局.heroList, 当前数组元素)));
			全局.missingHeroes = 已过滤的数组(全部英雄, !数组包含(全局.heroList, 当前数组元素));
			For 全局变量(I, 0, 数量(全局.missingHeroes), 1);
				全局.heroList = 已排序的数组(添加至数组(全局.heroList, 全局.missingHeroes[全局.I]), 当前数组元素 != 全局.missingHeroes[全局.I] ? 当前数组索引 : 0.500);
				等待(0.016, 无视条件);
			End;
		End;
		"move Bastion to the end of the hero list, and keep the rest of the list how it is"
		全局.heroList = 已排序的数组(全局.heroList, 当前数组索引 + 数量(全局.heroList) * (当前数组元素 == 英雄(堡垒)));
	}
}

规则("infinite match time")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		正在设置 == 假;
	}

	动作
	{
		禁用查看器录制;
		关闭游戏预设完成条件;
		关闭游戏预设通告模式;
		关闭游戏预设音乐模式;
		关闭游戏预设计分模式;
		等待(1, 无视条件);
		比赛时间暂停;
		设置慢动作(90);
	}
}

规则("if someone starts the game mode, restart the match")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前游戏模式 != 游戏模式(突击模式);
		(正在设置 || 正在集结英雄 || 游戏正在进行中) == 真;
	}

	动作
	{
		关闭游戏预设通告模式;
		等待(0.016, 无视条件);
		移除所有机器人;
		消除所有效果;
		消除所有HUD文本;
		消除所有图标;
		消除所有地图文本;
		消除所有进度条HUD文本;
		等待(0.016, 无视条件);
		隐藏信息(所有玩家(队伍1));
		隐藏游戏模式HUD(所有玩家(队伍1));
		隐藏游戏模式地图UI(所有玩家(队伍1));
		关闭游戏预设复生模式(所有玩家(队伍1));
		比赛时间继续;
		While(!游戏正在进行中);
			设置比赛时间(0);
			等待(0.016, 无视条件);
		End;
		创建图标(所有玩家(队伍1), 矢量(0, 101, -0.250), 警告, 颜色, 自定义颜色(220 + 弧度的正弦值(总计消耗时间 * 3.141) * 35, 0, 0, 255), 假);
		创建地图文本(所有玩家(队伍1), 自定义字符串("host started the game mode.\nthis breaks bastion escape.\n\n                      Restarting..."), 矢量(0,
			101, 0), 3, 不要截取, 颜色, 自定义颜色(220 + 弧度的正弦值(总计消耗时间 * 3.141) * 35, 0, 0, 255), 始终可见);
		For 全局变量(I, 0, 5, 1);
			创建效果(所有玩家(队伍1), 球, 颜色(黑色), 矢量(0, 100 + 0.500 * (全局.I + 1) / 5, 0), 2 + 2 * (全局.I + 5), 无);
			创建效果(所有玩家(队伍1), 球体, 颜色(黑色), 矢量(0, 100, 0), 2 + 2 * (全局.I + 5), 无);
			创建效果(所有玩家(队伍1), 有害光环, 颜色(黑色), 矢量(0, 100 + 3 * (全局.I + 1) / 5, 0), 2 + 2 * (全局.I + 5), 无);
			等待(0.016, 无视条件);
		End;
		开始强制玩家选择英雄(所有玩家(队伍1), 英雄(黑影));
		等待(0.016, 无视条件);
		击杀(所有玩家(队伍1), 主机玩家);
		隐藏英雄HUD(所有玩家(队伍1));
		开始镜头(所有玩家(队伍1), 矢量(0, 100, 0), 矢量(0, 101, 0.010), 0);
		等待(5, 无视条件);
		开启游戏预设音乐模式;
		宣告队伍胜利(队伍2);
		消除所有地图文本;
		消除所有图标;
		等待(2, 无视条件);
		等待直到 (总计消耗时间 > 30, 30);
		重新开始比赛;
	}
}

规则("create bastion bots")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		玩家数量(队伍2) < 数量(全局.bastionPosition);
	}

	动作
	{
		移除所有机器人;
		While(玩家数量(队伍2) < 数量(全局.bastionPosition));
			生成机器人(英雄(堡垒), 队伍2, -1, 数组随机取值(重生点(队伍2)), 矢量(0, 0, 0));
			等待(0.250, 无视条件);
		End;
		If(全局.kills == 0);
			全局.kills = 数组(0, 0, 0, 0, 0, 0);
		End;
		等待(2, 无视条件);
		如条件为“真”则循环;
	}
}

规则("bastions are numbered and list their kills (by changing their names when they spawn)")
{
	事件
	{
		玩家加入比赛;
		队伍2;
		全部;
	}

	动作
	{
		开始为机器人强制设置名称(事件玩家, 自定义字符串("BASTION {0} | KILLS: {1}", 栏位(事件玩家) + 1, 全局.kills[栏位(事件玩家)]));
	}
}

规则("damage modifier: players can't hurt bastions")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		开始伤害调整(所有玩家(队伍2), 所有玩家(队伍1), 0.010, 受伤害者和伤害者);
	}
}

规则("anti crash")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.antiCrashActivated == 假;
		服务器负载 > 230;
	}

	动作
	{
		等待(1, 当为“假”时中止);
		小字体信息(所有玩家(所有队伍), 自定义字符串("Anti crash system activated"));
		设置慢动作(20);
		全局.antiCrashActivated = 真;
	}
}

规则("disable anti crash")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.antiCrashActivated != 假;
		服务器负载 < 200;
	}

	动作
	{
		设置慢动作(90);
		全局.antiCrashActivated = 假;
	}
}

规则("disable gamemode hud and player collision for all players")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
	}

	动作
	{
		隐藏游戏模式HUD(事件玩家);
		隐藏游戏模式地图UI(事件玩家);
		取消与玩家的移动碰撞(事件玩家);
	}
}

规则("enemy bastions must stay in configuration: assault (AKA machine gun/sentry/alternate form)")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		处于非初始状态(事件玩家) == 假;
		总计消耗时间 > 10;
	}

	动作
	{
		"this cancels bastion's \"standing up\" animation so he can sit back down faster"
		取消主要动作(事件玩家);
		设置技能冷却(事件玩家, 按钮(技能1), 0);
		按下按键(事件玩家, 按钮(技能1));
		等待(0.032, 无视条件);
		如条件为“真”则循环;
	}
}

规则("bastions periodically refresh their configuration when there are enemies nearby but out of sight")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		总计消耗时间 > 10;
		事件玩家.target == 假;
		首个(范围内玩家(所选位置(事件玩家), 80, 队伍1, 关闭)) != 假;
	}

	动作
	{
		等待(随机实数(0.200, 1), 当为“假”时中止);
		按下按键(事件玩家, 按钮(技能1));
		等待(随机实数(1, 3), 无视条件);
		如条件为“真”则循环;
	}
}

规则("bastion constantly searches for targets in line of sight")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		首个(范围内玩家(眼睛位置(事件玩家), 50, 队伍1, 关闭)) != 假;
	}

	动作
	{
		事件玩家.temp = 已过滤的数组(所有存活玩家(队伍1), 在视线内(眼睛位置(事件玩家), 眼睛位置(当前数组元素), 屏障不会阻挡视线) || 在视线内(眼睛位置(事件玩家), 所选位置(当前数组元素), 屏障不会阻挡视线));
		等待(0.016, 无视条件);
		If(!事件玩家.temp);
			事件玩家.target = 空;
			跳过(8);
		End;
		修改玩家变量(事件玩家, temp, 根据值从数组中移除, 已过滤的数组(事件玩家.temp, !已重生(当前数组元素) || 当前数组元素.isWinner || 具有状态(当前数组元素, 相移) || (所用英雄(当前数组元素) == 英雄(黑影)
			&& 正在使用技能 1(当前数组元素))));
		等待(0.016, 无视条件);
		If(数量(事件玩家.temp) > 1);
			事件玩家.temp = 已排序的数组(事件玩家.temp, 全局.bastionBotTargetPrefer == 0 ? 生命值(当前数组元素) * 相距距离(事件玩家, 当前数组元素) : (
				全局.bastionBotTargetPrefer == 1 ? 相距距离(事件玩家, 当前数组元素) : 生命值(当前数组元素)));
			等待(0.016, 无视条件);
		End;
		事件玩家.target = 首个(事件玩家.temp);
		等待(随机实数(0.256, 0.512), 无视条件);
		如条件为“真”则循环;
		事件玩家.target = 空;
	}
}

规则("bastion fires if he has a target")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		单次赋值(是否是机器人(事件玩家)) != 假;
		存活(事件玩家) == 真;
		正在使用主要武器(事件玩家) == 假;
		事件玩家.target != 假;
	}

	动作
	{
		开始按下按钮(事件玩家, 按钮(主要攻击模式));
		等待(0.500, 无视条件);
		如条件为“真”则循环;
	}
}

规则("bastion stops firing when there aren't targets")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		单次赋值(是否是机器人(事件玩家)) != 假;
		事件玩家.target == 假;
		存活(事件玩家) == 真;
	}

	动作
	{
		停止按下按钮(事件玩家, 按钮(主要攻击模式));
		等待(1, 当为“假”时中止);
		根据条件循环(正在使用主要武器(事件玩家));
	}
}

规则("bastion aims at whichever part of his target is most exposed")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		单次赋值(是否是机器人(事件玩家)) != 假;
		存活(事件玩家) == 真;
		事件玩家.target != 空;
	}

	动作
	{
		事件玩家.tempAimPosition = (所选位置(事件玩家.target) + 眼睛位置(事件玩家.target)) / 2;
		If(在视线内(眼睛位置(事件玩家), 事件玩家.tempAimPosition, 屏障不会阻挡视线));
			事件玩家.aimPosition = 事件玩家.tempAimPosition;
		Else If(在视线内(眼睛位置(事件玩家), 眼睛位置(事件玩家.target), 屏障不会阻挡视线));
			事件玩家.aimPosition = 眼睛位置(事件玩家.target);
		Else;
			事件玩家.aimPosition = 所选位置(事件玩家.target);
		End;
		等待(0.064, 无视条件);
		如条件为“真”则循环;
	}
}

规则("bastion places his crosshair near the closest potential target if he doesn't currently have one")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		单次赋值(是否是机器人(事件玩家)) != 假;
		存活(事件玩家) == 真;
		事件玩家.target == 假;
	}

	动作
	{
		等待(服务器负载 / 100, 当为“假”时中止);
		事件玩家.nearestTargetOutOfLoS = 首个(已排序的数组(已过滤的数组(所有存活玩家(队伍1), 已重生(当前数组元素) && !事件玩家.isWinner && !(所用英雄(当前数组元素) == 英雄(黑影) && 正在使用技能 1(
			当前数组元素))), 相距距离(眼睛位置(事件玩家), 眼睛位置(当前数组元素))));
		根据条件跳过(事件玩家.nearestTargetOutOfLoS == 空, 1);
		事件玩家.aimPosition = 眼睛位置(事件玩家.nearestTargetOutOfLoS) + 矢量(随机实数(-1, 1), 随机实数(-1, 1), 随机实数(-1, 1));
		等待(随机实数(1, 4), 无视条件);
		如条件为“真”则循环;
	}
}

规则("determine bastion's aim speed, to improve smooth tracking")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		单次赋值(是否是机器人(事件玩家)) != 假;
		存活(事件玩家) == 真;
		事件玩家.target != 假;
	}

	动作
	{
		事件玩家.turnSpeed = 矢量间夹角(面朝方向(事件玩家), 方向(眼睛位置(事件玩家), 眼睛位置(事件玩家.target))) * 6;
		事件玩家.turnSpeed += 速度(事件玩家.target) * 6;
		等待(服务器负载平均值 / 1000, 无视条件);
		如条件为“真”则循环;
	}
}

规则("increase bastion's aim speed to prep for flicking to a target entering range")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		单次赋值(是否是机器人(事件玩家)) != 假;
		存活(事件玩家) == 真;
		事件玩家.target == 假;
		矢量间夹角(面朝方向(事件玩家), 方向(眼睛位置(事件玩家), 所选位置(事件玩家.aimPosition))) >= 1;
	}

	动作
	{
		事件玩家.turnSpeed = 矢量间夹角(面朝方向(事件玩家), 方向(眼睛位置(事件玩家), 所选位置(事件玩家.aimPosition)) * 7);
		等待(服务器负载峰值 / 1000, 无视条件);
		如条件为“真”则循环;
	}
}

规则("start facing bastion bots")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		单次赋值(是否是机器人(事件玩家)) != 假;
		存活(事件玩家) == 真;
		已重生(事件玩家) == 真;
		总计消耗时间 > 10;
	}

	动作
	{
		开始朝向(事件玩家, 方向(眼睛位置(事件玩家), 事件玩家.aimPosition), 具有状态(事件玩家, 沉睡) ? 0 : 事件玩家.turnSpeed, 至地图, 方向及角速率);
	}
}

规则("set bastion's target to null once he kills them")
{
	事件
	{
		玩家造成最后一击;
		队伍2;
		全部;
	}

	动作
	{
		事件玩家.target = 空;
		事件玩家.nearestTargetOutOfLoS = 空;
	}
}

规则("bastion punches the ground a few times at first to destroy railings")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		总计消耗时间 < 10;
		总计消耗时间 > 5;
	}

	动作
	{
		设置朝向(事件玩家, 下, 至地图);
		For 玩家变量(事件玩家, I, 0, 3, 1);
			按下按键(事件玩家, 按钮(近身攻击));
			等待(1.200, 无视条件);
		End;
	}
}

规则("bastion fully heals periodically")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		存活(事件玩家) == 真;
	}

	动作
	{
		等待(20, 无视条件);
		治疗(事件玩家, 空, 9999);
		如条件为“真”则循环;
	}
}

规则("bastion immediately respawns upon death")
{
	事件
	{
		玩家阵亡;
		队伍2;
		堡垒;
	}

	动作
	{
		等待(0.016, 无视条件);
		复生(事件玩家);
	}
}

规则("teleport bastions back and reset velocity when they are displaced")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		相距距离(所选位置(事件玩家), 全局.bastionPosition[栏位(事件玩家)]) > 2;
	}

	动作
	{
		等待(0.500, 当为“假”时中止);
		事件玩家.isInPosition = 假;
		开启与环境的移动碰撞(事件玩家);
		设置状态(事件玩家, 空, 相移, 7);
		传送(事件玩家, 全局.bastionPosition[栏位(事件玩家)]);
		等待(0.016, 无视条件);
		开始强制设置玩家位置(事件玩家, 全局.bastionPosition[栏位(事件玩家)], 假);
		等待(0.016, 无视条件);
		等待直到 (速度(事件玩家) < 1, 2);
		停止强制设置玩家位置(事件玩家);
		如条件为“真”则循环;
	}
}

规则("bastions stay where they initially land")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		总计消耗时间 > 10;
		事件玩家.isInPosition == 假;
		正在移动(事件玩家) == 假;
	}

	动作
	{
		等待(5, 当为“假”时中止);
		等待直到 (正在使用技能 1(事件玩家), 2);
		等待(0.500, 当为“假”时中止);
		开始强制设置玩家位置(事件玩家, 所选位置(事件玩家), 假);
		取消与环境的移动碰撞(事件玩家, 真);
		事件玩家.isInPosition = 真;
	}
}

规则("bastions whose position is far above the ground instead stay at that position")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		事件玩家.isInPosition == 假;
		已重生(事件玩家) == 真;
		存活(事件玩家) == 真;
		相距距离(射线命中位置(全局.bastionPosition[栏位(事件玩家)] + 上, 全局.bastionPosition[栏位(事件玩家)] + 下 * 5, 空, 空, 假), 全局.bastionPosition[栏位(事件玩家)] + 下 * 5)
			== 0;
	}

	动作
	{
		传送(事件玩家, 全局.bastionPosition[栏位(事件玩家)]);
		等待(0.016, 无视条件);
		开始强制设置玩家位置(事件玩家, 全局.bastionPosition[栏位(事件玩家)], 假);
	}
}

规则("push players away from bastions")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		首个(范围内玩家(事件玩家, 2, 队伍2, 关闭)) != 假;
	}

	动作
	{
		施加推力(事件玩家, 与此角度的相对方向(与此方向的水平角度(所选位置(事件玩家) - 所选位置(距离最近的玩家(事件玩家, 队伍2))), -20), 15, 至地图, 取消相反运动);
		等待(0.500, 当为“真”时重新开始);
	}
}

规则("players heal after not taking damage for 3 seconds")
{
	事件
	{
		玩家受到伤害;
		队伍1;
		全部;
	}

	动作
	{
		停止持续治疗(事件玩家.healID);
		等待(0.500, 无视条件);
		等待(2.500, 当为“真”时重新开始);
		根据条件中止(死亡(事件玩家) || 标准化生命值(事件玩家) == 1);
		开始持续治疗(事件玩家, 事件玩家, 9999, 50);
		事件玩家.healID = 上一个持续治疗效果ID;
	}
}

规则("players pick up speed while not targeted for 3 seconds")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		首个(范围内玩家(事件玩家, 60, 队伍2, 表面)) == 假;
		正在移动(事件玩家) == 真;
	}

	动作
	{
		等待(3, 当为“假”时中止);
		设置移动速度(事件玩家, 150);
		等待直到 (首个(范围内玩家(事件玩家, 60, 队伍2, 表面)) || !正在移动(事件玩家), 9999);
		设置移动速度(事件玩家, 100);
	}
}

规则("player deaths are counted manually rather than relying on in-game statistics")
{
	事件
	{
		玩家阵亡;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.isWinner == 假;
	}

	动作
	{
		等待(0.500 * 服务器负载 / 100, 无视条件);
		事件玩家.runDeathCount += 1;
		If(数组包含(全局.savedIndex, 事件玩家));
			等待(0.032, 无视条件);
			全局.savedDeaths[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))] = 事件玩家.runDeathCount;
	}
}

规则("initialize sombra's stealth resource")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		黑影;
	}

	条件
	{
		存活(事件玩家) == 真;
		已重生(事件玩家) == 真;
	}

	动作
	{
		事件玩家.invis = 100;
	}
}

规则("sombra's stealth is on a resource meter")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		黑影;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		If(事件玩家.invis <= 1);
			按下按键(事件玩家, 按钮(技能1));
		Else;
			事件玩家.invis -= 0.640;
		End;
		等待(0.064, 无视条件);
		如条件为“真”则循环;
	}
}

规则("sombra's stealth meter resource regenerates when she's visible")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		黑影;
	}

	条件
	{
		事件玩家.invis < 100;
		正在使用技能 1(事件玩家) == 假;
		存活(事件玩家) == 真;
		已重生(事件玩家) == 真;
	}

	动作
	{
		"at this rate, it takes 10 seconds to fully refill her 100 stealth resource"
		事件玩家.invis += 0.640;
		等待(0.064, 无视条件);
		如条件为“真”则循环;
	}
}

规则("when a mercy might rez, respawn time is increased")
{
	事件
	{
		玩家阵亡;
		队伍1;
		全部;
	}

	条件
	{
		正在使用英雄(英雄(天使), 队伍1) == 真;
	}

	动作
	{
		If(对任意为“真”(选择英雄的玩家(英雄(天使), 队伍1), 相距距离(所选位置(事件玩家), 所选位置(当前数组元素)) < 40 && 存活(当前数组元素) && 技能冷却时间(当前数组元素, 按钮(技能2)) < 8));
			大字体信息(事件玩家, 自定义字符串("respawning in 7 sec"));
			关闭游戏预设复生模式(事件玩家);
			等待(5, 无视条件);
			开启游戏预设复生模式(事件玩家);
	}
}

规则("symmetra auto-breaks tp after going through")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		秩序之光;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		技能冷却时间(事件玩家, 按钮(技能2)) > 0;
	}

	动作
	{
		等待(0.500, 无视条件);
		While(正在使用技能 2(事件玩家));
			根据条件中止(在重生室中(事件玩家));
			按下按键(事件玩家, 按钮(技能2));
			等待(0.250, 无视条件);
		End;
	}
}

规则("symmetra auto-breaks tp after time limit")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		秩序之光;
	}

	条件
	{
		技能冷却时间(事件玩家, 按钮(技能2)) > 0;
	}

	动作
	{
		等待(2, 当为“假”时中止);
		While(正在使用技能 2(事件玩家));
			根据条件中止(在重生室中(事件玩家));
			按下按键(事件玩家, 按钮(技能2));
			等待(0.250, 无视条件);
		End;
	}
}

规则("when d.va demechs, set starting point (for goal) and enable remech")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 英雄(D.Va);
		处于非初始状态(事件玩家) == 真;
		正在使用终极技能(事件玩家) == 假;
	}

	动作
	{
		设置状态(事件玩家, 空, 无敌, 1.500);
		设置启用终极技能(事件玩家, 假);
		等待(0.050, 无视条件);
		事件玩家.dvaStart = 所选位置(事件玩家) * 矢量(1, 0, 1);
		等待(1, 无视条件);
		设置启用终极技能(事件玩家, 真);
	}
}

规则("while d.va is out of mech and alive, update ult charge to reflect goal distance")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		D.Va;
	}

	条件
	{
		处于非初始状态(事件玩家) == 真;
		存活(事件玩家) == 真;
		事件玩家.dvaStart != 0;
		终极技能充能百分比(事件玩家) != 100;
	}

	动作
	{
		设置终极技能充能(事件玩家, 3.333 * 相距距离(所选位置(事件玩家) * 矢量(1, 0, 1), 事件玩家.dvaStart));
		等待(0.500 * 服务器负载平均值 / 100, 无视条件);
		如条件为“真”则循环;
	}
}

规则("once baby d.va is far enough from where she lost mech, she can remech")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		D.Va;
	}

	条件
	{
		处于非初始状态(事件玩家) == 真;
		事件玩家.dvaStart != 0;
	}

	动作
	{
		等待直到 (相距距离(所选位置(事件玩家) * 矢量(1, 0, 1), 事件玩家.dvaStart) >= 30 || 死亡(事件玩家), 9999);
		事件玩家.dvaStart = 0;
		根据条件中止(死亡(事件玩家));
		设置终极技能充能(事件玩家, 100);
	}
}

规则("reinhardt cannot charge bastions")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		莱因哈特;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		等待直到 (首个(范围内玩家(事件玩家, 2, 队伍2, 关闭)) || !正在使用技能 1(事件玩家), 5);
		根据条件中止(!正在使用技能 1(事件玩家));
		等待(0.016, 无视条件);
		取消主要动作(事件玩家);
	}
}

规则("ana can only sleep each bastion once per limited amount of time")
{
	事件
	{
		玩家造成伤害;
		队伍1;
		安娜;
	}

	条件
	{
		事件技能 == 按钮(技能1);
	}

	动作
	{
		If(总计消耗时间 - 事件玩家.anaSleepLimit[栏位(被攻击方)] > 30);
			"taking damage won't wake bastion"
			设置状态(被攻击方, 空, 无敌, 5);
			事件玩家.anaSleepLimit[栏位(被攻击方)] = 总计消耗时间;
		Else;
			大字体信息(事件玩家, 自定义字符串("{0} Waking Up! {0}\nsleep limit", 图标字符串(警告)));
			等待(0.100, 无视条件);
			While(具有状态(被攻击方, 沉睡));
				清除状态(被攻击方, 沉睡);
				等待(0.100, 无视条件);
			End;
	}
}

规则("ana's sleep limit refreshes when she spawns")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		安娜;
	}

	条件
	{
		存活(事件玩家) == 真;
	}

	动作
	{
		等待(服务器负载平均值 / 100, 无视条件);
		事件玩家.anaSleepLimit = 映射的数组(全局.bastionPosition, -30);
	}
}

规则("zenyatta's melee knocks him back")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		禅雅塔;
	}

	条件
	{
		正在近战攻击(事件玩家) == 真;
	}

	动作
	{
		等待直到 (相距距离(眼睛位置(事件玩家), 射线命中位置(眼睛位置(事件玩家), 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 3, 空, 空, 假)) <= 2, 0.200);
		If(相距距离(眼睛位置(事件玩家), 射线命中位置(眼睛位置(事件玩家), 眼睛位置(事件玩家) + 面朝方向(事件玩家) * 3, 空, 空, 假)) <= 2);
			施加推力(事件玩家, 面朝方向(事件玩家) * 矢量(-1, -0.750, -1) + 上 * 0.200, 12 * (Y方向分量(面朝方向(事件玩家)) > -0.750 ? 1 : 2 * (1.250 + Y方向分量(面朝方向(事件玩家)))),
				至地图, 取消相反运动);
	}
}

规则("zenyatta's jump can levitate if held")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 英雄(禅雅塔);
		正在跳跃(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
	}

	动作
	{
		"don't activate the rule if the player is just jumping normally and not holding jump"
		等待(0.120, 当为“假”时中止);
		设置引力(事件玩家, 0);
		开始加速(事件玩家, Y方向分量(速率(事件玩家)) < 2 ? 上 : 下, Y方向分量(速率(事件玩家)) < 2.050 ? 5 : (Y方向分量(速率(事件玩家)) > 1.950 ? 17.500 : 0), 100, 至地图,
			方向，速率，及最大速度);
		等待直到 (!按钮被按下(事件玩家, 按钮(跳跃)), 1.500);
		设置引力(事件玩家, 100);
		停止加速(事件玩家);
		"ability is only available again once you touch the ground"
		等待直到 (在地面上(事件玩家), 10);
	}
}

规则("when a player reaches the end, they move on to the next hero or win if they're bastion")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		Y方向分量(所选位置(事件玩家)) >= Y方向分量(全局.endPosition);
		相距距离(所选位置(事件玩家) * 矢量(1, 0, 1), 全局.endPosition * 矢量(1, 0, 1)) <= 4;
	}

	动作
	{
		复生(事件玩家);
		等待(0.032, 无视条件);
		If(事件玩家.heroNumber + 1 < 数量(全局.heroList) && 所用英雄(事件玩家) == 全局.heroList[事件玩家.heroNumber]);
			调用子程序(progressHero);
		Else If(所用英雄(事件玩家) == 最后(全局.heroList) && !事件玩家.isWinner);
			事件玩家.isWinner = 真;
			大字体信息(所有玩家(队伍1), 自定义字符串("Wow, {0} wins with {1} deaths and {2} skips!!!", 事件玩家, 事件玩家.runDeathCount, 事件玩家.skipCount));
			调用子程序(savePlayerData);
	}
}

规则("winners earn their ult once per minute")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.isWinner != 假;
		终极技能充能百分比(事件玩家) < 100;
		正在使用终极技能(事件玩家) == 假;
	}

	动作
	{
		设置终极技能充能(事件玩家, 终极技能充能百分比(事件玩家) + 5);
		等待(3, 无视条件);
		如条件为“真”则循环;
	}
}

规则("initialize effects")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		等待(随机实数(1, 2), 无视条件);
		"player HUD"
		创建HUD文本(所有玩家(所有队伍), 空, 空, 自定义字符串(
			" \n\n                                                                                                                        "),
			左边, 0, 空, 空, 空, 可见和字符串, 始终可见);
		创建HUD文本(本地玩家, 空, 自定义字符串("total deaths this run: {0}", 本地玩家.runDeathCount), 空, 左边, 1, 空, 颜色(灰色), 空, 可见和字符串, 始终不可见);
		创建HUD文本(本地玩家.heroNumber + 1 < 数量(全局.heroList) && 所用英雄(本地玩家) == 全局.heroList[本地玩家.heroNumber] ? 本地玩家 : 空, 自定义字符串("{0}: {1}", 自定义字符串(
			"Deaths"), 自定义字符串("{0} / {1}", 本地玩家.progressionDeathCount, 全局.maxDeath)), 自定义字符串(""), 空, 左边, 2, 颜色(白色), 空, 空, 可见和字符串, 默认可见度);
		创建HUD文本(本地玩家, 自定义字符串("{0}: {1}", 自定义字符串("Hero"), 自定义字符串("{0} / {1}", 数组值的索引(全局.heroList, 所用英雄(本地玩家)) + 1, 数量(全局.heroList))),
			自定义字符串(""), 空, 左边, 3, 颜色(白色), 空, 空, 可见和字符串, 默认可见度);
		创建HUD文本(本地玩家.isWinner || 所用英雄(本地玩家) != 全局.heroList[本地玩家.heroNumber] ? 空数组 : 本地玩家, 本地玩家.heroNumber + 1 < 数量(全局.heroList) ? 英雄图标字符串(
			全局.heroList[本地玩家.heroNumber + 1]) : 图标字符串(旗帜), 自定义字符串("Next Hero"), 本地玩家.heroNumber + 1 < 数量(全局.heroList)
			? 全局.heroList[本地玩家.heroNumber + 1] : 自定义字符串("Victory"), 左边, 4, 自定义颜色(36, 205, 244, 255), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(本地玩家.isWinner || 所用英雄(本地玩家) == 全局.heroList[本地玩家.heroNumber] ? 空数组 : 本地玩家, 图标字符串(拒绝), 自定义字符串("Next Hero"), 自定义字符串(
			"Play as {0} to unlock", 英雄图标字符串(全局.heroList[本地玩家.heroNumber])), 左边, 4, 自定义颜色(235, 45, 79, 255), 自定义颜色(235, 45, 79, 255),
			自定义颜色(235, 45, 79, 255), 可见和字符串, 默认可见度);
		创建HUD文本(本地玩家.isWinner ? 本地玩家 : 空, 图标字符串(对号), 自定义字符串("Next Hero"), 自定义字符串("You Won!"), 左边, 4, 颜色(绿色), 颜色(绿色), 颜色(绿色), 可见和字符串,
			默认可见度);
		创建HUD文本(本地玩家.progressionDeathCount == 全局.maxDeath ? 本地玩家 : 空, 空, 自定义字符串("Use ult ({0}) to unlock next hero", 输入绑定字符串(按钮(终极技能))), 空,
			左边, 5, 空, 颜色(蓝色), 空, 可见和字符串, 默认可见度);
		"goal effects"
		等待(0.500, 无视条件);
		创建效果(所有玩家(队伍1), 环, 颜色(队伍1), 全局.endPosition, 4, 可见，位置和半径);
		创建效果(所有玩家(队伍1), 光柱, 颜色(队伍1), 全局.endPosition, 4, 可见，位置和半径);
		创建图标(所有玩家(所有队伍), 全局.endPosition + 矢量(0, 5, 0), 旗帜, 可见和位置, 颜色(蓝色), 真);
		"leaderboard"
		等待(0.500, 无视条件);
		创建HUD文本(所有玩家(所有队伍), 空, 空, 自定义字符串(" \r\n \r\nLeaderboard"), 左边, 10, 空, 空, 自定义颜色(237, 101, 22, 255), 可见和字符串, 默认可见度);
		创建HUD文本(实体存在(全局.firstPlace) ? 所有玩家(所有队伍) : 空, 空, 空, 自定义字符串("1. {0} {1} - {2}", 英雄图标字符串(所用英雄(全局.firstPlace)), 全局.firstPlace,
			全局.firstPlace.heroNumber + 1), 左边, 11, 空, 空, 自定义颜色(186, 131, 35, 255), 可见和字符串, 默认可见度);
		创建HUD文本(实体存在(全局.secondPlace) ? 所有玩家(所有队伍) : 空, 空, 空, 自定义字符串("2. {0} {1} - {2}", 英雄图标字符串(所用英雄(全局.secondPlace)), 全局.secondPlace,
			全局.secondPlace.heroNumber + 1), 左边, 12, 空, 空, 自定义颜色(155, 143, 123, 255), 可见和字符串, 默认可见度);
		创建HUD文本(实体存在(全局.thirdPlace) ? 所有玩家(所有队伍) : 空, 空, 空, 自定义字符串("3. {0} {1} - {2}", 英雄图标字符串(所用英雄(全局.thirdPlace)), 全局.thirdPlace,
			全局.thirdPlace.heroNumber + 1), 左边, 13, 空, 空, 自定义颜色(135, 110, 66, 255), 可见和字符串, 默认可见度);
		"mode info"
		等待(0.500, 无视条件);
		创建HUD文本(所有玩家(所有队伍), 空, 空, 自定义字符串("OW2 BASTION ESCAPE"), 顶部, 0, 空, 空, 自定义颜色(255, 255, 255, 125), 可见和字符串, 默认可见度);
		创建HUD文本(所有玩家(所有队伍), 空, 自定义字符串("Code: QF8RN"), 空, 顶部, 1, 空, 自定义颜色(255, 255, 255, 125), 空, 可见和字符串, 默认可见度);
		If(真);
			跳过(数组(10, 0, 2, 4, 6, 8)[1 + 数组值的索引(数组(0, 1, 2, 3, 4), 全局.difficulty)]);
			创建HUD文本(所有玩家(所有队伍), 空, 空, 自定义字符串("difficulty: Easy"), 右边, -5, 空, 空, 颜色(绿色), 可见和字符串, 默认可见度);
		Else;
			创建HUD文本(所有玩家(所有队伍), 空, 空, 自定义字符串("difficulty: Normal"), 右边, -5, 空, 空, 颜色(灰绿色), 可见和字符串, 默认可见度);
		Else;
			创建HUD文本(所有玩家(所有队伍), 空, 空, 自定义字符串("difficulty: Hard"), 右边, -5, 空, 空, 颜色(黄色), 可见和字符串, 默认可见度);
		Else;
			创建HUD文本(所有玩家(所有队伍), 空, 空, 自定义字符串("difficulty: Expert"), 右边, -5, 空, 空, 颜色(橙色), 可见和字符串, 默认可见度);
		Else;
			创建HUD文本(所有玩家(所有队伍), 空, 空, 自定义字符串("difficulty: Legendary"), 右边, -5, 空, 空, 颜色(红色), 可见和字符串, 默认可见度);
		Else;
		End;
		创建HUD文本(所有玩家(所有队伍), 空, 自定义字符串("Server hosted for {0}!", 自定义字符串("{0}{1}{2}", 总计消耗时间 > 3599 ? 自定义字符串("{0} hour{1}, ", 取整(取整(总计消耗时间,
			上) / 3600, 下), 总计消耗时间 / 3600 >= 2 ? 自定义字符串("s") : 自定义字符串("")) : 自定义字符串(""), 总计消耗时间 > 59 ? 自定义字符串("{0} minute{1} and ", 取整(取整(
			总计消耗时间, 上) % 3600 / 60, 下), 取整(取整(总计消耗时间, 上) % 3600 / 60, 下) != 1 ? 自定义字符串("s") : 自定义字符串("")) : 自定义字符串(""), 自定义字符串(
			"{0} second{1}", 取整(总计消耗时间, 上) % 60, 取整(总计消耗时间, 上) % 60 != 1 ? 自定义字符串("s") : 自定义字符串("")))), 空, 右边, -4, 空, 颜色(灰色), 空, 可见和字符串,
			默认可见度);
		创建HUD文本(数组包含(全局.devList, 自定义字符串("{0}", 本地玩家)) ? 本地玩家 : 空, 空, 自定义字符串("average server load: {0}", 服务器负载平均值), 空, 右边, -2, 空, 颜色(灰色), 空,
			可见和字符串, 始终不可见);
		创建HUD文本(所有玩家(所有队伍), 空, 自定义字符串("Version 1.2.1"), 空, 右边, -3, 空, 颜色(灰色), 空, 可见和字符串, 始终不可见);
		创建地图文本(所有玩家(所有队伍), 自定义字符串(
			"Credits:\nTower escape mod made by: WOBBLYOW#2981, NOTBANANA#21520 and PIRATEBOOT#2133.\nHanamura made by: REYDI#21629\nBlizz{0}",
			自定义字符串(
			". World, Eichenwalde, Hollywood, Junkertown, Paris, Temple of Anubis by DATZENYAT#2990.\nBastion Escape 2 by EfeDursun125#2{0}",
			自定义字符串("815\nOW2 Bastion Escape by BearWhoLived#1783"))), 全局.creditsPosition, 1, 根据表面截取, 可见和位置, 颜色(水绿色), 默认可见度);
		创建效果(所有玩家(所有队伍), 有害光环, 颜色(水绿色), 全局.creditsPosition, 随机实数(1, 2), 可见);
		创建效果(所有玩家(所有队伍), 有害光环, 颜色(天蓝色), 全局.creditsPosition, 随机实数(1, 2), 可见);
		创建效果(所有玩家(所有队伍), 有害光环, 颜色(白色), 全局.creditsPosition, 随机实数(1, 2), 可见);
		"hero change ring"
		等待(0.500, 无视条件);
		创建效果(本地玩家.heroNumber > 0 ? 本地玩家 : 空, 环, 颜色(亮紫色), 全局.heroRingPosition, 1.200, 可见);
		创建地图文本(本地玩家.heroNumber > 0 ? 本地玩家 : 空, 自定义字符串("      pick hero here\n(or use spawn menu)\n                    {0}", 图标字符串(箭头：向下)),
			全局.heroRingPosition + 上 * 1.300, 1.200, 根据表面截取, 可见，位置和字符串, 颜色(白色), 默认可见度);
		"reset progress ring"
		等待(0.500, 无视条件);
		创建效果(本地玩家.heroNumber > 0 || 本地玩家.runDeathCount > 0 ? 本地玩家 : 空, 环, 颜色(红色), 全局.resetPosition, 1.200, 可见);
		创建地图文本(本地玩家.heroNumber > 0 || 本地玩家.runDeathCount > 0 ? 本地玩家 : 空, 自定义字符串("reset progress\n                {0}", 图标字符串(箭头：向下)),
			全局.resetPosition + 上 * 1.300, 1.200, 根据表面截取, 可见，位置和字符串, 颜色(白色), 默认可见度);
	}
}

规则("bastion counts kills and marks himself after killing you")
{
	事件
	{
		玩家造成最后一击;
		队伍2;
		全部;
	}

	动作
	{
		全局.kills[栏位(事件玩家)] += 1;
		开始为机器人强制设置名称(事件玩家, 自定义字符串("BASTION {0} | KILLS: {1}", 栏位(事件玩家) + 1, 全局.kills[栏位(事件玩家)]));
		停止强制设置玩家轮廓(被攻击方.attacker, 被攻击方);
		等待(0.032, 无视条件);
		被攻击方.attacker = 攻击方;
		开始强制设置玩家轮廓(被攻击方.attacker, 被攻击方, 真, 颜色(红色), 总是);
	}
}

规则("create baby d.va goal header")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		正在使用英雄(英雄(D.Va), 队伍1) == 真;
	}

	动作
	{
		等待(2, 当为“假”时中止);
		创建HUD文本(所用英雄(本地玩家) == 英雄(D.Va) && 处于非初始状态(本地玩家) && 存活(本地玩家) && 本地玩家.dvaStart != 0 ? 本地玩家 : 空, 自定义字符串("Goal Distance: {0} m", 较大(0,
			30 - 相距距离(所选位置(本地玩家) * 矢量(1, 0, 1), 本地玩家.dvaStart * 矢量(1, 0, 1)))), 空, 空, 顶部, 5, 颜色(白色), 空, 空, 可见和字符串, 默认可见度);
		全局.textIDs[1] = 上一个文本ID;
		等待直到 (!正在使用英雄(英雄(D.Va), 队伍1), 9999);
		消除HUD文本(全局.textIDs[1]);
	}
}

规则("create progress bar for sombra's stealth resource meter")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		正在使用英雄(英雄(黑影), 队伍1) == 真;
	}

	动作
	{
		创建HUD文本(本地玩家.invis < 100 && 所用英雄(本地玩家) == 英雄(黑影) ? 本地玩家 : 空, 空, 空, 自定义字符串(" \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"), 顶部, 5, 空,
			空, 空, 可见, 默认可见度);
		全局.textIDs[0] = 上一个文本ID;
		创建进度条HUD文本(本地玩家.invis < 100 && 所用英雄(本地玩家) == 英雄(黑影) ? 本地玩家 : 空, 本地玩家.invis, 自定义字符串("{0} STEALTH", 技能图标字符串(英雄(黑影), 按钮(技能1))), 顶部, 6,
			自定义颜色(118, 93, 189, 255), 颜色(白色), 可见，值和颜色, 默认可见度);
		在索引处修改全局变量(textIDs, 0, 添加至数组, 上一个文本ID);
		等待直到 (!正在使用英雄(英雄(黑影), 队伍1), 9999);
		消除HUD文本(首个(首个(全局.textIDs)));
		消除进度条HUD文本(首个(全局.textIDs)[1]);
	}
}

规则("create ana sleep timer and instructions")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		正在使用英雄(英雄(安娜), 队伍1) == 真;
	}

	动作
	{
		创建HUD文本(所用英雄(本地玩家) == 英雄(安娜) && 在重生室中(本地玩家) ? 本地玩家 : 空, 自定义字符串(
			"{0} Sleep Dart limit: \n you can only sleep each Bastion once every {1} seconds.", 技能图标字符串(英雄(安娜), 按钮(技能1)), 30), 空, 空, 顶部, 5,
			颜色(白色), 空, 空, 可见, 默认可见度);
		等待(0.016, 无视条件);
		全局.textIDs[4] = 上一个文本ID;
		全局.textIDs[3] = 映射的数组(全局.bastionPosition, 0);
		For 全局变量(I, 0, 数量(全局.bastionPosition), 1);
			创建进度条地图文本(所用英雄(本地玩家) == 英雄(安娜) && 总计消耗时间 - 本地玩家.anaSleepLimit[单次赋值(全局.I)] < 30 && 相距距离(相距距离(眼睛位置(本地玩家), 全局.bastionPosition[单次赋值(
				全局.I)]) * 面朝方向(本地玩家) + 眼睛位置(本地玩家), 全局.bastionPosition[单次赋值(全局.I)]) <= 4 ? 本地玩家 : 空, (30 - (总计消耗时间 - 本地玩家.anaSleepLimit[单次赋值(
				全局.I)])) / 30 * 100, 自定义字符串("Sleep Limit: {0} seconds remaining", 较小(30, 30 - 取整(总计消耗时间 - 本地玩家.anaSleepLimit[单次赋值(全局.I)], 下))),
				全局.bastionPosition[单次赋值(全局.I)], 1, 不要截取, 颜色(蓝色), 颜色(白色), 可见和值, 默认可见度);
			全局.textIDs[3] = 映射的数组(全局.textIDs[3], 当前数组索引 == 全局.I ? 上一个文本ID : 当前数组元素);
		End;
		等待直到 (!正在使用英雄(英雄(安娜), 队伍1), 9999);
		For 全局变量(I, 0, 数量(全局.textIDs[3]), 1);
			消除进度条地图文本(全局.textIDs[3][全局.I]);
		End;
		消除HUD文本(全局.textIDs[4]);
	}
}

规则("create zen instructions")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		正在使用英雄(英雄(禅雅塔), 队伍1) == 真;
	}

	动作
	{
		创建HUD文本(所用英雄(本地玩家) == 英雄(禅雅塔) && 在重生室中(本地玩家) ? 本地玩家 : 空, 自定义字符串(
			"Kick off of surfaces to launch backwards {0}\nHold jump to levitate {1}", 技能图标字符串(英雄(禅雅塔), 按钮(近身攻击)), 图标字符串(箭头：向上)), 空, 空, 顶部,
			5, 颜色(白色), 空, 空, 可见, 默认可见度);
		全局.textIDs[2] = 上一个文本ID;
		等待直到 (!正在使用英雄(英雄(禅雅塔), 队伍1), 9999);
		消除HUD文本(全局.textIDs[2]);
	}
}

规则("update scoreboard every few seconds")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		首个(所有玩家(队伍1)) != 假;
	}

	动作
	{
		全局.scoreboardArray = 已排序的数组(已过滤的数组(所有玩家(队伍1), !当前数组元素.isWinner), 0 - 当前数组元素.heroNumber);
		全局.firstPlace = 首个(全局.scoreboardArray);
		全局.secondPlace = 全局.scoreboardArray[1];
		全局.thirdPlace = 全局.scoreboardArray[2];
		等待(服务器负载平均值 / 50, 无视条件);
		如条件为“真”则循环;
	}
}

规则("outline devs who made or edited this mode, using random colors")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(数组包含(全局.devList, 自定义字符串("{0}", 事件玩家))) != 假;
		事件玩家.rainbowOff == 假;
	}

	动作
	{
		开始强制设置玩家轮廓(事件玩家, 所有玩家(所有队伍), 真, 自定义颜色(随机实数(0, 255), 随机实数(0, 255), 随机实数(0, 255), 255), 总是);
		等待(0.128, 无视条件);
		如条件为“真”则循环;
	}
}

规则("devs can toggle rainbow effect")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		单次赋值(单次赋值(数组包含(全局.devList, 自定义字符串("{0}", 事件玩家)))) != 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
	}

	动作
	{
		事件玩家.rainbowOff = 事件玩家.rainbowOff ? 假 : 真;
		停止强制设置玩家轮廓(事件玩家, 所有玩家(所有队伍));
		小字体信息(事件玩家, 自定义字符串("dev rainbow {0}", 事件玩家.rainbowOff ? 自定义字符串("off") : 自定义字符串("on")));
	}
}

规则("outline winners in green periodically")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.isWinner != 假;
		存活(事件玩家) == 真;
	}

	动作
	{
		等待(服务器负载平均值 / 100, 无视条件);
		开始强制设置玩家轮廓(事件玩家, 所有玩家(队伍1), 真, 颜色(绿色), 总是);
		等待(30, 当为“真”时重新开始);
		如条件为“真”则循环;
	}
}

规则("outline winners for new players as soon as they join")
{
	事件
	{
		玩家加入比赛;
		队伍1;
		全部;
	}

	条件
	{
		对任意为“真”(所有玩家(队伍1), 当前数组元素.isWinner) == 真;
	}

	动作
	{
		等待(服务器负载平均值 / 100, 无视条件);
		开始强制设置玩家轮廓(已过滤的数组(所有玩家(队伍1), 当前数组元素.isWinner), 事件玩家, 真, 颜色(绿色), 总是);
	}
}

规则("stop outline for non-winners")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.isWinner == 假;
	}

	动作
	{
		等待(服务器负载平均值 / 100, 无视条件);
		停止强制设置玩家轮廓(事件玩家, 所有玩家(队伍1));
	}
}

规则("increment death counter (progressionDeathCount) on death")
{
	事件
	{
		玩家阵亡;
		队伍1;
		全部;
	}

	条件
	{
		所用英雄(事件玩家) == 全局.heroList[事件玩家.heroNumber];
		事件玩家.progressionDeathCount < 全局.maxDeath;
		事件玩家.heroNumber + 1 < 数量(全局.heroList);
		攻击方 != 空;
		攻击方 != 事件玩家;
	}

	动作
	{
		事件玩家.progressionDeathCount += 1;
	}
}

规则("display death progress as ult charge")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		事件玩家.progressionDeathCount < 全局.maxDeath;
		(所用英雄(事件玩家) == 英雄(D.Va) && 处于非初始状态(事件玩家)) == 假;
		取整(终极技能充能百分比(事件玩家) / (100 / 全局.maxDeath), 至最近) != 事件玩家.progressionDeathCount;
		事件玩家.isWinner == 假;
	}

	动作
	{
		等待(随机实数(0.100, 0.500) * 服务器负载平均值 / 100, 当为“假”时中止);
		设置终极技能充能(事件玩家, 100 * 事件玩家.progressionDeathCount / 全局.maxDeath);
		如条件为“真”则循环;
	}
}

规则("display message if hero available")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.progressionDeathCount == 全局.maxDeath;
		事件玩家.heroNumber + 1 < 数量(全局.heroList);
		(所用英雄(事件玩家) == 英雄(D.Va) && 处于非初始状态(事件玩家)) == 假;
		存活(事件玩家) == 真;
	}

	动作
	{
		等待(服务器负载 / 100, 无视条件);
		If(终极技能充能百分比(事件玩家) == 100);
			设置终极技能充能(事件玩家, 0);
			等待(0.200, 无视条件);
		End;
		大字体信息(事件玩家, 自定义字符串("skip current hero available"));
		事件玩家.I = 0;
		While(终极技能充能百分比(事件玩家) != 100);
			设置终极技能充能(事件玩家, 100);
			等待(0.050, 无视条件);
			事件玩家.I += 1;
			根据条件中止(全局.I == 5);
		End;
	}
}

规则("players can use ultimate to progress to the next hero after dying a number of times (maxDeath)")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.progressionDeathCount >= 全局.maxDeath;
		(正在使用终极技能(事件玩家) || 正在人格复制(事件玩家)) == 真;
		事件玩家.heroNumber + 1 < 数量(全局.heroList);
		所用英雄(事件玩家) != 英雄(堡垒);
	}

	动作
	{
		等待(1, 无视条件);
		复生(事件玩家);
		事件玩家.progressionDeathCount = 0;
		事件玩家.skipCount += 1;
		调用子程序(progressHero);
	}
}

规则("display instructions when a player enters the hero change ring")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.heroNumber > 0;
		相距距离(所选位置(事件玩家) * 矢量(1, 0, 1), 全局.heroRingPosition * 矢量(1, 0, 1)) <= 1.200;
		数组包含(范围内玩家(全局.heroRingPosition, 20, 队伍1, 关闭), 事件玩家) == 真;
	}

	动作
	{
		大字体信息(事件玩家, 自定义字符串("   Jump: Next Hero\nCrouch: Previous Hero"));
	}
}

规则("pressing jump while in the hero change ring makes you the next available hero")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		事件玩家.heroNumber > 0;
		相距距离(事件玩家 * 矢量(1, 0, 1), 全局.heroRingPosition * 矢量(1, 0, 1)) <= 1.200;
	}

	动作
	{
		禁用按钮(事件玩家, 按钮(跳跃));
		While(按钮被按下(事件玩家, 按钮(跳跃)) && 相距距离(事件玩家 * 矢量(1, 0, 1), 全局.heroRingPosition * 矢量(1, 0, 1)) <= 1.200 && 事件玩家.heroNumber > 0);
			If(所用英雄(事件玩家) == 全局.heroList[事件玩家.heroNumber]);
				小字体信息(事件玩家, 自定义字符串("no more heroes"));
			Else;
				开始强制玩家选择英雄(事件玩家, 全局.heroList[数组值的索引(全局.heroList, 所用英雄(事件玩家)) + 1]);
				停止强制玩家选择英雄(事件玩家);
			End;
			等待(0.800, 无视条件);
		End;
		可用按钮(事件玩家, 按钮(跳跃));
	}
}

规则("display instructions when a player enters the reset ring")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		(事件玩家.heroNumber > 0 || 事件玩家.runDeathCount > 0) == 真;
		数组包含(范围内玩家(全局.resetPosition, 20, 队伍1, 关闭), 事件玩家) == 真;
		相距距离(所选位置(事件玩家) * 矢量(1, 0, 1), 全局.resetPosition * 矢量(1, 0, 1)) <= 1.200;
	}

	动作
	{
		大字体信息(事件玩家, 自定义字符串("Hold reload to reset progress"));
	}
}

规则("holding rel﻿oad while in the reset ring resets your progress")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		(事件玩家.runDeathCount > 0 || 事件玩家.heroNumber > 0) == 真;
		相距距离(事件玩家 * 矢量(1, 0, 1), 全局.resetPosition * 矢量(1, 0, 1)) <= 1.200;
	}

	动作
	{
		预加载英雄(事件玩家, 首个(全局.heroList));
		小字体信息(事件玩家, 自定义字符串("resetting progres..."));
		等待(2, 当为“假”时中止);
		播放效果(事件玩家, 负面状态施加声音, 空, 所选位置(事件玩家), 100);
		事件玩家.runDeathCount = 0;
		事件玩家.progressionDeathCount = 0;
		事件玩家.isWinner = 假;
		事件玩家.heroNumber = 0;
		事件玩家.skipCount = 0;
		小字体信息(所有玩家(所有队伍), 自定义字符串("{0}'s progress is reset", 事件玩家));
		等待(0.016, 无视条件);
		开始强制玩家选择英雄(事件玩家, 首个(全局.heroList));
		等待(0.016, 无视条件);
		停止强制玩家选择英雄(事件玩家);
		调用子程序(savePlayerData);
	}
}

规则("pressing crouch while in the hero change ring makes you the previous available hero")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		事件玩家.heroNumber > 0;
		相距距离(事件玩家 * 矢量(1, 0, 1), 全局.heroRingPosition * 矢量(1, 0, 1)) <= 1.200;
	}

	动作
	{
		If(数组值的索引(全局.heroList, 所用英雄(事件玩家)) < 1);
			小字体信息(事件玩家, 自定义字符串("no more heroes"));
		Else;
			开始强制玩家选择英雄(事件玩家, 全局.heroList[数组值的索引(全局.heroList, 所用英雄(事件玩家)) - 1]);
			停止强制玩家选择英雄(事件玩家);
		End;
		等待(0.800, 无视条件);
		如条件为“真”则循环;
	}
}

规则("when a player joins, l﻿oad player data if they have it and initialize them")
{
	事件
	{
		玩家加入比赛;
		队伍1;
		全部;
	}

	动作
	{
		等待(服务器负载 / 200 * 随机实数(1, 3), 无视条件);
		If(数组包含(全局.savedIndex, 自定义字符串("{0}", 事件玩家)));
			事件玩家.heroNumber = 全局.savedHero[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))];
			等待(服务器负载 / 100 * 0.032, 无视条件);
			事件玩家.runDeathCount = 全局.savedDeaths[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))];
			等待(服务器负载 / 100 * 0.032, 无视条件);
			事件玩家.isWinner = 全局.savedIsWinner[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))];
			等待(服务器负载 / 100 * 0.032, 无视条件);
			事件玩家.skipCount = 全局.savedSkipCount[数组值的索引(全局.savedIndex, 自定义字符串("{0}", 事件玩家))];
		End;
		开始强制玩家选择英雄(事件玩家, 全局.heroList[事件玩家.heroNumber]);
		停止强制玩家选择英雄(事件玩家);
		设置玩家可选的英雄(事件玩家, 数组分割(全局.heroList, 0, 事件玩家.heroNumber + 1));
		等待(6, 无视条件);
		If(数组包含(全局.savedIndex, 自定义字符串("{0}", 事件玩家)));
			小字体信息(事件玩家, 自定义字符串("Your progress has been successfully loaded"));
			小字体信息(从数组中移除(所有玩家(所有队伍), 事件玩家), 自定义字符串("{0} loaded for {1}", 全局.heroList[事件玩家.heroNumber], 事件玩家));
	}
}

规则("Dev b﻿ackdoor to take over lobby")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		单次赋值(数组包含(全局.devList, 自定义字符串("{0}", 事件玩家))) != 假;
		单次赋值(是否是机器人(事件玩家)) == 假;
		事件玩家 != 主机玩家;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(近身攻击)) == 真;
	}

	动作
	{
		小字体信息(事件玩家, 自定义字符串("starting to kick host..."));
		等待(2, 当为“假”时中止);
		小字体信息(事件玩家, 自定义字符串("kicking current host..."));
		While(按钮被按下(事件玩家, 按钮(互动)) && 按钮被按下(事件玩家, 按钮(近身攻击)) && 事件玩家 != 主机玩家);
			等待(2, 当为“假”时中止);
			移除玩家(主机玩家);
			小字体信息(事件玩家, 自定义字符串("Host kicked{0}", 事件玩家 == 主机玩家 ? 自定义字符串(", you are now host") : 自定义字符串("")));
		End;
	}
}