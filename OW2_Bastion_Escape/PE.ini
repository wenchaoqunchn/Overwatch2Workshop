设置
{
	主程序
	{
		描述: "*February 22, 2024: No longer being maintained!!!\r\n \r\nWork together and escape with all available Heroes. \r\n\r\nAn alternative to Bastion Escape 2. PRISON ESCAPE is more challenging than Bastion Escape 2, yet lack the chaoticness and features of UNFAIR ESCAPE.\r\n-------------------------------\r\nOTHER CODES:\r\nUNFAIR ESCAPE Code: -> N0B1R\r\n-------------------------------\r\nhttps://workshop.codes/BKYTT\r\n\r\nCredit: By LOFIMUSIC#1110."
		模式名称: "PRISON ESCAPE"
	}

	大厅
	{
		地图轮换: 完成比赛后
		比赛结束后转换队伍: 否
		比赛语音聊天: 启用
		玩家上限 队伍1: 10
		玩家上限 队伍2: 0
		观战者人数上限: 12
		返回大厅: 从不
		队列中的玩家可以加入: 是
	}

	模式
	{
		攻击护送
		{
			启用地图
			{
				中城 972777519512068153 972777519512068154
			}
		}

		突击模式
		{
			禁用地图
			{
				中城
				地图工坊室内
				地图工坊岛屿
				地图工坊岛屿（夜间）
				地图工坊空地
				地图工坊空地（夜间）
				地图工坊绿幕
				新渣客城
				花冈
				苏拉瓦萨
				阿努比斯王座
				鲁纳塞彼
			}
		}

		综合
		{
			复生时间: 40%
			急救包刷新: 开启
			急救包刷新时间: 10%
			敌方生命条: 关闭
			游戏模式开始: 即时
			英雄限制: 关闭
		}
	}

	英雄
	{
		队伍1
		{
			堡垒
			{
				生命值: 135%
			}

			黑影
			{
				位移传动冷却时间: 150%
			}
		}

		队伍2
		{
			堡垒
			{
				切换模式冷却时间: 0%
				无需装弹: 开启
				生命值: 135%
				终极技能（火炮模式）: 关闭
				近身攻击: 关闭
			}
		}

		综合
		{
			战斗时终极技能充能速度: 0%
			技能冷却时间: 45%
			无需装弹: 开启
			终极技能充能速度: 10%
			终极技能自动充能速度: 0%

			半藏
			{
				“岚”数量: 12
				“跃”距离设置: 125%
			}

			天使
			{
				可用武器: 仅限天使之杖
				辅助攻击模式: 关闭
			}

			奥丽莎
			{
				终极技能（撼地猛刺）: 关闭
			}

			安娜
			{
				麻醉镖冷却时间: 200%
			}

			巴蒂斯特
			{
				受到治疗量: 10%
				弹道速度: 500%
				愈合冲击冷却时间: 15%
				投射物重力: 0%
				无需装弹: 开启
				生命值: 10%
				维生力场冷却时间: 15%
			}

			托比昂
			{
				可用武器: 仅限锻造锤
				热力过载冷却时间: 150%
				热力过载持续时间: 350%
				部署炮台: 关闭
			}

			查莉娅
			{
				垂直跳跃速度: 140%
				粒子炮辅助攻击击退倍率: 200%
			}

			生命之梭
			{
				生命之握冷却时间: 101%
				生命之握和愈疗灵花射程: 130%
			}

			禅雅塔
			{
				乱: 关闭
				治疗量: 200%
				生命值: 175%
			}

			秩序之光
			{
				传送面板冷却时间: 300%
				哨戒炮: 关闭
			}

			路霸
			{
				链钩: 关闭
			}

			禁用英雄
			{
				探奇
				朱诺
				骇灾
			}
		}
	}

	地图工坊
	{
		# of heroes to escape with: [1]
	}

	扩展
	{
		生成更多机器人
	}
}

变量
{
	全局:
		0: ScoreboardArray
		1: EndPosition
		3: WinnerCountToCycleWS
		4: CurWinnerCount
		5: IsDVADebug
		6: IsDebugMode
		7: HeroEscapeLimitWS
		9: JumpPadLocList
		10: JumpPadPowerList
		15: AllBastionPositions
		16: TempVar
		17: GameOptTextVec
		18: GameOptTextSpacing
		21: BacktrackMinMaxListWS
		23: BacktrackDeathsWS
		26: BastionBotTargetPreferWS
		27: GameSettingsHUDWT
		33: BlizzWorldSpawnLoc
		35: HollywoodSpawnLoc
		36: BadHollywoodSpawnLoc
		37: isTeleporterEnabled
		38: JumpPadRadius
		39: WinnerHeroesList
		41: ResetRerollRingStats
		44: GameSettingTextVec

	玩家:
		0: IsWinner
		1: attacker
		2: temp
		3: CurrentHero
		5: Deaths
		6: DVADebugStates
		7: DVAHUD
		8: BacktrackDeaths
		9: randBacktrackNum
		14: PlayerProgressVisibility
		20: TargetHero
		26: Enemy
		27: AimPosition
		28: TurnSpeed
		29: TempAimPosition
		30: EnemyUnSeen
		33: IndieHeroList
}

子程序
{
	0: SliceIndieHeroList
	1: DestroyDVAMechHUD
	3: SpawnAtAltLoc
	5: CreateJumpPads
	6: IncrementGameSettingsPos
	7: CreateTeleporters
	8: SetupGameSettingsText
}

规则("Workshop Settings")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.BastionBotTargetPreferWS = 地图工坊设置组合(自定义字符串("1) Game"), 自定义字符串("Bastion Bot Target Prefer System"), 0, 数组(自定义字符串("Dynamic"),
			自定义字符串("Nearest"), 自定义字符串("Lowest Health")), 0);
		全局.BacktrackDeathsWS = 地图工坊设置整数(自定义字符串("3) Backtracking"), 自定义字符串("# of deaths before backtracking"), 5, 1, 999, 0);
		全局.BacktrackMinMaxListWS = 空数组;
		全局.BacktrackMinMaxListWS[0] = 地图工坊设置整数(自定义字符串("3) Backtracking"), 自定义字符串("Minimum random number to backtrack by"), 1, 1, 31, 0);
		全局.BacktrackMinMaxListWS[1] = 地图工坊设置整数(自定义字符串("3) Backtracking"), 自定义字符串("Maximum random number to backtrack by"), 2, 1, 31, 1);
		全局.BacktrackMinMaxListWS = 数组(较小(全局.BacktrackMinMaxListWS[0], 全局.BacktrackMinMaxListWS[1]), 较大(全局.BacktrackMinMaxListWS[0],
			全局.BacktrackMinMaxListWS[1]));
		全局.WinnerCountToCycleWS = 地图工坊设置整数(自定义字符串("1) Game"), 自定义字符串("Winners needed to cycle map(0=disabled)"), 3, 0, 100, 0);
		全局.HeroEscapeLimitWS = 地图工坊设置组合(自定义字符串("2) Hero Ordering"), 自定义字符串("# of heroes to escape with"), 1, 数组(自定义字符串("All"), 自定义字符串(
			"Classic (34)"), 自定义字符串("Blitz (16)")), 0);
	}
}

规则("init winner hero list")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.WinnerHeroesList == 空;
	}

	动作
	{
		全局.WinnerHeroesList = 全部英雄;
	}
}

规则("slice independent hero order list [SR]")
{
	事件
	{
		子程序;
		SliceIndieHeroList;
	}

	动作
	{
		事件玩家.IndieHeroList = 随机数组(全部英雄);
		"HeroEscapeLimitWS: 0 = All Heroes, 1 = 34 Heroes"
		If(全局.HeroEscapeLimitWS == 1);
			事件玩家.IndieHeroList = 数组分割(事件玩家.IndieHeroList, 0, 34);
		"HeroEscapeLimitWS: 2 = Blitz(16)"
		Else If(全局.HeroEscapeLimitWS == 2);
			事件玩家.IndieHeroList = 数组分割(事件玩家.IndieHeroList, 0, 16);
	}
}

规则("Init independent hero list")
{
	事件
	{
		玩家加入比赛;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.IndieHeroList == 空;
	}

	动作
	{
		调用子程序(SliceIndieHeroList);
	}
}

规则("Global Stats & inits")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		禁用查看器录制;
		关闭游戏预设完成条件;
		设置慢动作(90);
		创建HUD文本(所有玩家(所有队伍), 空, 空, 自定义字符串("https://Workshop.codes/BKYTT\nSERVER CPU: {0}%\r\n", 取整(服务器负载 / 255 * 100, 至最近)), 左边, -1000, 颜色(
			白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(所有玩家(所有队伍), 空, 空, 自定义字符串(" \r\n \r\nProgress Board:"), 左边, 10, 颜色(白色), 颜色(白色), 颜色(水绿色), 可见和字符串, 默认可见度);
		创建HUD文本(所有玩家(所有队伍), 空, 空, 自定义字符串("{0}", 全局.ScoreboardArray[0] == 空 ? 自定义字符串(" ") : 自定义字符串("♠ {0} {1} - {2}", 英雄图标字符串(所用英雄(
			全局.ScoreboardArray[0])), 全局.ScoreboardArray[0], 全局.ScoreboardArray[0].TargetHero + 1)), 左边, 11, 颜色(白色), 颜色(白色), 颜色(绿色), 可见和字符串,
			默认可见度);
		创建HUD文本(所有玩家(所有队伍), 空, 空, 自定义字符串("{0}", 全局.ScoreboardArray[1] == 空 ? 自定义字符串(" ") : 自定义字符串("♠ {0} {1} - {2}", 英雄图标字符串(所用英雄(
			全局.ScoreboardArray[1])), 全局.ScoreboardArray[1], 全局.ScoreboardArray[1].TargetHero + 1)), 左边, 12, 颜色(白色), 颜色(白色), 颜色(黄色), 可见和字符串,
			默认可见度);
		创建HUD文本(所有玩家(所有队伍), 空, 空, 自定义字符串("{0}", 全局.ScoreboardArray[2] == 空 ? 自定义字符串(" ") : 自定义字符串("♠ {0} {1} - {2}", 英雄图标字符串(所用英雄(
			全局.ScoreboardArray[2])), 全局.ScoreboardArray[2], 全局.ScoreboardArray[2].TargetHero + 1)), 左边, 13, 颜色(白色), 颜色(白色), 颜色(红色), 可见和字符串,
			默认可见度);
		创建HUD文本(已过滤的数组(所有玩家(队伍1), 当前数组元素.IsWinner), 自定义字符串("Go To Spawn: \n(Hold) [{0}] + [{1}] + [{2}]", 输入绑定字符串(按钮(装填)), 输入绑定字符串(按钮(跳跃)),
			输入绑定字符串(按钮(互动))), 空, 空, 左边, 9, 颜色(水绿色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(所有玩家(所有队伍), 空, 空, 自定义字符串("PRISON ESCAPE"), 顶部, 0, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(所有玩家(所有队伍), 空, 自定义字符串("Code: BKYTT"), 空, 顶部, 1, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		全局.JumpPadRadius = 2.500;
		全局.ResetRerollRingStats = 数组(空, 1.750, 空, 矢量(0, 1, 0));
	}
}

禁用 规则("map setting (global arr p, global b, global d, global c) - [template]")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		"Insert map name here"
		当前地图 == 空;
	}

	动作
	{
		"Position of all Bastion on the map"
		全局.AllBastionPositions = 数组(空, 空, 空, 空, 空, 空, 空);
		"Goal position"
		全局.EndPosition = 左 - 左;
		开始强制重生室(队伍1, 2);
		"ring position"
		全局.ResetRerollRingStats[0] = 矢量(0, 0, 0);
		"Text height. default: (0,1,0)"
		全局.ResetRerollRingStats[3] = 矢量(0, 0, 0);
		"Base coordinates for world game settings HUD"
		全局.GameSettingTextVec = 矢量(0, 0, 0);
	}
}

禁用 规则("Teleporter position init (global T) [template]")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.T == 空数组;
		当前地图 == 空;
	}

	动作
	{
		"Even indexes (0, 2, ...)  are portal senders. Odd indexes (1, 3, ...) are portal receivers. Example: 0 index sends players to 1 index position."
		全局.T = 数组(矢量(0, 0, 0), 矢量(0, 0, 0));
	}
}

禁用 规则("Jump pad position init (global J)(global K) [template]")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.JumpPadLocList == 空数组;
		当前地图 == 空;
	}

	动作
	{
		"The location of the jump pad"
		修改全局变量(JumpPadLocList, 添加至数组, 左 - 左);
		"The strength of the jump pad. How high to to bounce players upwards?"
		修改全局变量(JumpPadPowerList, 添加至数组, 0);
	}
}

规则("Map Cycling")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.WinnerCountToCycleWS != 0;
		全局.CurWinnerCount >= 全局.WinnerCountToCycleWS;
	}

	动作
	{
		大字体信息(所有玩家(队伍1), 自定义字符串("     Winner Limit Reached!\n\nMap will cycle soon!"));
		等待(3, 当为“假”时中止);
		等待(300, 当为“假”时中止);
		大字体信息(所有玩家(队伍1), 自定义字符串("Map will cycle in 5 mins!"));
		等待(2, 当为“假”时中止);
		等待(240, 当为“假”时中止);
		大字体信息(所有玩家(队伍1), 自定义字符串("Map will cycle in 60 secs!"));
		等待(2, 当为“假”时中止);
		等待(60, 当为“假”时中止);
		大字体信息(所有玩家(队伍1), 自定义字符串("Cycling Map!"));
		等待(3, 当为“假”时中止);
		重新开始比赛;
	}
}

规则("map setting (global arr p, global b, global d, global c) - samoa (all)")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		"Insert map name here"
		当前地图 == 地图(萨摩亚);
	}

	动作
	{
		开始强制重生室(队伍1, 2);
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		等待直到 (对任意为“真”(所有玩家(队伍1), 已重生(当前数组元素)), 99999);
		"Volcano"
		If(数量(范围内玩家(矢量(102.419, 344.132, 411.687), 20, 队伍1, 关闭)) != 0);
			"Position of all Bastion on the map"
			全局.AllBastionPositions = 数组(矢量(46.893, 346.682, 386.957), 矢量(62.483, 344.963, 348.681), 矢量(27.438, 346.846, 374.903), 矢量(1.193,
				344.825, 361.528), 矢量(7.295, 346.813, 387.640), 矢量(-0.772, 343.827, 391.768), 矢量(-26.107, 343.758, 378.399));
			"Goal position"
			全局.EndPosition = 矢量(-40.394, 343.669, 404.797) - 矢量(0, 5, 0);
			全局.ResetRerollRingStats[0] = 矢量(102.463, 344.131, 405.382);
			"Base coordinates for world game settings HUD"
			全局.GameSettingTextVec = 矢量(94.850, 344.500, 413.813);
		"Beach"
		Else If(数量(范围内玩家(矢量(-428, 11.502, -109), 20, 队伍1, 关闭)) != 0);
			"Position of all Bastion on the map"
			全局.AllBastionPositions = 数组(矢量(-383.134, 13.097, -87.740), 矢量(-385.487, 10.866, -123.535), 矢量(-336.436, 11.740, -115.401), 矢量(
				-291.712, 11.209, -77.840), 矢量(-275.258, 13.222, -87.038), 矢量(-273.927, 10.880, -122.860), 矢量(-241.364, 15.460, -127.915));
			"Goal position"
			全局.EndPosition = 矢量(-241.371, 11.056, -111.549) - 矢量(0, 5, 0);
			全局.ResetRerollRingStats[0] = 矢量(-424.056, 11.380, -105.112);
			"Base coordinates for world game settings HUD"
			全局.GameSettingTextVec = 矢量(-423.878, 11.545, -116.519);
		"Downtown"
		Else;
			"Position of all Bastion on the map"
			全局.AllBastionPositions = 数组(矢量(272.469, 13.682, -235.270), 矢量(228.541, 8.013, -256.387), 矢量(241.044, 7.317, -258.329), 矢量(224.786,
				10.200, -222.212), 矢量(210.838, 10.686, -282.977), 矢量(195.728, 13.682, -235.853), 矢量(152.144, 14.883, -237.252));
			"Goal position"
			全局.EndPosition = 矢量(157.196, 13.427, -225.715) - 矢量(0, 2, 0);
			全局.ResetRerollRingStats[0] = 矢量(323.230, 15.779, -225.459);
			"Base coordinates for world game settings HUD"
			全局.GameSettingTextVec = 矢量(317.082, 16, -215.974);
		End;
		全局.ResetRerollRingStats[3] = 矢量(0, 0.300, 0);
	}
}

规则("map setting (global arr p, global b, global d, global c) - midtown")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		"Insert map name here"
		当前地图 == 地图(中城);
	}

	动作
	{
		"Position of all Bastion on the map"
		全局.AllBastionPositions = 数组(矢量(117.608, 8.055, -62.965), 矢量(92.321, 9.873, -22.078), 矢量(58.475, 12.301, -6.372), 矢量(59.220, 10.399,
			38.729), 矢量(18.248, 13.276, 47.731), 矢量(-2.793, 6.792, 74.422), 矢量(8.766, 11.450, 95.669));
		"Goal position"
		全局.EndPosition = 矢量(12.700, 3.199, 126.770);
		开始强制重生室(队伍1, 2);
		"ring position"
		全局.ResetRerollRingStats[0] = 矢量(121.342, 2.643, -108.655);
		"Base coordinates for world game settings HUD"
		全局.GameSettingTextVec = 矢量(126.508, 2.643, -106.569);
	}
}

规则("map setting (global arr p, global b, global d, global c) - esperanca")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		"Insert map name here"
		当前地图 == 地图(埃斯佩兰萨);
	}

	动作
	{
		"Position of all Bastion on the map"
		全局.AllBastionPositions = 数组(矢量(44.800, -1.110, -73.440), 矢量(17.024, 6.678, -36.948), 矢量(0.170, 0.216, -54.917), 矢量(0.096, 9.760,
			13.853), 矢量(-17.008, 6.671, -37.039), 矢量(-59.121, 2.192, -71.328), 矢量(-66.672, 1.450, -36.691));
		"Goal position"
		全局.EndPosition = 矢量(-91.314, -4.827, -67.849);
		开始强制重生室(队伍1, 2);
		"ring position"
		全局.ResetRerollRingStats[0] = 矢量(128.970, -0.500, -74.996);
		"Base coordinates for world game settings HUD"
		全局.GameSettingTextVec = 矢量(118.305, 0.238, -82.843);
	}
}

规则("map setting (global arr p, global b, global d, global c) - new queen street")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		"Insert map name here"
		当前地图 == 地图(新皇后街);
	}

	动作
	{
		"Position of all Bastion on the map"
		全局.AllBastionPositions = 数组(矢量(-74.738, 15.563, -16.781), 矢量(-6.399, 6.385, -6.691), 矢量(-23.552, 5.489, -27.335), 矢量(30.990, 7.170,
			-5.570), 矢量(2.939, 7.701, 25.856), 矢量(23.589, 5.289, -27.123), 矢量(75.375, 15.327, -15.400));
		"Goal position"
		全局.EndPosition = 矢量(75.374, 5.690, -24.875);
		开始强制重生室(队伍1, 2);
		"ring position"
		全局.ResetRerollRingStats[0] = 矢量(-106.430, 12, -15.326);
		"Base coordinates for world game settings HUD"
		全局.GameSettingTextVec = 矢量(-103.939, 12, -24.447);
	}
}

规则("map setting (global arr p, global b, global d, global c) - colesseo")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		"Insert map name here"
		当前地图 == 地图(斗兽场);
	}

	动作
	{
		"Position of all Bastion on the map"
		全局.AllBastionPositions = 数组(矢量(63.412, 13.806, -14.025), 矢量(31.551, 8.789, -3.412), 矢量(7.479, 9.205, 2.768), 矢量(-7.487, 9.205,
			2.712), 矢量(-42.361, 5.300, -40.204), 矢量(-31.556, 8.789, -4.703), 矢量(-80.467, 10.300, -17.389));
		"Goal position"
		全局.EndPosition = 矢量(-87.553, 6.414, -32.201);
		开始强制重生室(队伍1, 2);
		全局.ResetRerollRingStats[0] = 矢量(104.602, 9.600, -53.426);
		"Base coordinates for world game settings HUD"
		全局.GameSettingTextVec = 矢量(114.109, 10.600, -36.315);
	}
}

规则("map setting (global arr p, global b, global d, global c) - antarctic peninsula (all)")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		"Insert map name here"
		当前地图 == 地图(南极半岛);
	}

	动作
	{
		开始强制重生室(队伍1, 2);
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		等待直到 (对任意为“真”(所有玩家(队伍1), 已重生(当前数组元素)), 99999);
		"Labs"
		If(数量(范围内玩家(矢量(369.964, 47.934, 172.554), 20, 队伍1, 关闭)) != 0);
			"Position of all Bastion on the map"
			全局.AllBastionPositions = 数组(矢量(325.431, 49.281, 165.954), 矢量(296.271, 48.019, 160.080), 矢量(270.040, 44.992, 154.327), 矢量(269.940,
				43.990, 188.570), 矢量(243.724, 48.276, 159.745), 矢量(207.924, 53.489, 179.563), 矢量(345.690, 48.284, 194.644));
			"Goal position"
			全局.EndPosition = 矢量(182.833, 48.709, 179.424) - 矢量(0, 5, 0);
			全局.ResetRerollRingStats[0] = 矢量(368.053, 46.928, 166.257);
			"Base coordinates for world game settings HUD"
			全局.GameSettingTextVec = 矢量(365.169, 46.928, 171.372);
		"Icebreaker"
		Else If(数量(范围内玩家(矢量(182.372, -8.392, -231.351), 20, 队伍1, 关闭)) != 0);
			"Position of all Bastion on the map"
			全局.AllBastionPositions = 数组(矢量(244.448, -8.079, -226.308), 矢量(284.147, -6.753, -248.967), 矢量(275.774, -8.186, -209.947), 矢量(
				292.113, -8.183, -209.816), 矢量(318.397, -7.496, -206.332), 矢量(339.914, -6.545, -242.235), 矢量(323.199, -9.535, -229.584));
			"Goal position"
			全局.EndPosition = 矢量(359.245, -8.253, -225.622) - 矢量(0, 2, 0);
			全局.ResetRerollRingStats[0] = 矢量(176.943, -6.184, -216.640);
			"Base coordinates for world game settings HUD"
			全局.GameSettingTextVec = 矢量(186.375, -8.121, -232.162);
		"Sublevel"
		Else;
			"Position of all Bastion on the map"
			全局.AllBastionPositions = 数组(矢量(-101.303, -148.991, 99.981), 矢量(-77.744, -153.214, 60.015), 矢量(-48.747, -159.642, 59.796), 矢量(
				-91.860, -149.884, 37.044), 矢量(-93.590, -149.893, 25.813), 矢量(-72.068, -150.084, 2.029), 矢量(-100.174, -154.181, -1.046));
			"Goal position"
			全局.EndPosition = 矢量(-83.194, -150.636, -17.293) - 矢量(0, 2, 0);
			全局.ResetRerollRingStats[0] = 矢量(-88.153, -150.191, 154.078);
			"Base coordinates for world game settings HUD"
			全局.GameSettingTextVec = 矢量(-77.726, -150.190, 148.856);
		End;
		全局.ResetRerollRingStats[3] = 矢量(0, 0.300, 0);
	}
}

规则("map setting (global arr p, global b, global d, global c) - shambali monastery")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		"Insert map name here"
		当前地图 == 地图(香巴里寺院);
	}

	动作
	{
		"Position of all Bastion on the map"
		全局.AllBastionPositions = 数组(矢量(-47.124, 31.309, 148.783), 矢量(3.368, 28.300, 114.852), 矢量(-18.489, 24.550, 87.747), 矢量(-38.835,
			17.915, 69.706), 矢量(-12.821, 16.301, 60.007), 矢量(-23.987, 16.247, 23.140), 矢量(-30.591, 32.298, 191.678));
		"Goal position"
		全局.EndPosition = 矢量(3.511, 9.301, -3.620) - 矢量(0, 2, 0);
		开始强制重生室(队伍1, 2);
		全局.ResetRerollRingStats[0] = 矢量(-7.693, 32.516, 227.048);
		全局.ResetRerollRingStats[3] = 矢量(0, 0, 0);
		"Base coordinates for world game settings HUD"
		全局.GameSettingTextVec = 矢量(-7.583, 31.914, 220.682);
	}
}

规则("map setting (global arr p, global b, global d, global c) - numbani")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(努巴尼);
	}

	动作
	{
		全局.AllBastionPositions = 数组(矢量(179.102, 4.250, 13.115), 矢量(154.224, -4.180, 13.616), 矢量(118.815, 4.250, 3.556), 矢量(76.458, 7.470,
			-22.061), 矢量(34.438, 5.300, 12.271), 矢量(13.762, 3.708, 1.104), 矢量(84.452, 7.995, 15.353));
		全局.EndPosition = 矢量(6.984, -1, 5.778);
		开始强制重生室(队伍1, 1);
		"Base coordinates for world game settings HUD"
		全局.GameSettingTextVec = 矢量(241.550, 1.665, 22.677);
		全局.ResetRerollRingStats[0] = 矢量(238.587, 1.505, 26.771);
	}
}

规则("map setting (global arr p, global b, global d, global c) - paraiso")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		"Insert map name here"
		当前地图 == 地图(帕拉伊苏);
	}

	动作
	{
		"Position of all Bastion on the map"
		全局.AllBastionPositions = 数组(矢量(-25.886, 9.907, -157.941), 矢量(6.934, 13.215, -123.704), 矢量(-0.649, 12.300, -81.334), 矢量(-13.707,
			9.525, -43.063), 矢量(5.488, 5.490, 7.937), 矢量(-31.415, 2.558, 32.838), 矢量(-4.904, 6.549, -2.642));
		"Goal position"
		全局.EndPosition = 矢量(-35.859, -0.833, 53.162) - 矢量(0, 2, 0);
		开始强制重生室(队伍1, 2);
		全局.ResetRerollRingStats[0] = 矢量(-69.920, 5.701, -186.300);
		全局.ResetRerollRingStats[3] = 矢量(0, 0.800, 0);
		"Base coordinates for world game settings HUD"
		全局.GameSettingTextVec = 矢量(-71.112, 6.050, -182.319);
	}
}

规则("map setting (global arr p, global b, global d, global c) - circuit royal")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		"Insert map name here"
		当前地图 == 地图(皇家赛道);
	}

	动作
	{
		"Position of all Bastion on the map"
		全局.AllBastionPositions = 数组(矢量(93.780, 23.168, 38.957), 矢量(68.212, 12.258, 30.514), 矢量(59.711, 20.268, 16.273), 矢量(38.630, 21.275,
			-20.723), 矢量(-7.665, 7.119, 1.483), 矢量(-18.710, 14.446, -45.619), 矢量(15.896, 16.820, -44.630));
		"Goal position"
		全局.EndPosition = 矢量(-59.196, 5.459, -43.177) - 矢量(0, 2, 0);
		开始强制重生室(队伍1, 2);
		全局.ResetRerollRingStats[0] = 矢量(127.268, 12.073, 2.732);
		全局.ResetRerollRingStats[3] = 矢量(0, 0.400, 0);
		"Base coordinates for world game settings HUD"
		全局.GameSettingTextVec = 矢量(132.413, 12.079, -2.841);
	}
}

规则("map setting (global arr p, global b, global d, global c) - oasis(all)")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		"Insert map name here"
		当前地图 == 地图(绿洲城);
	}

	动作
	{
		开始强制重生室(队伍1, 2);
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		等待直到 (对任意为“真”(所有玩家(队伍1), 已重生(当前数组元素)), 99999);
		"University"
		If(数量(范围内玩家(矢量(-193.743, 21.300, 91.204), 40, 队伍1, 关闭)) != 0);
			全局.AllBastionPositions = 数组(矢量(-168.599, 22.258, 68.245), 矢量(-198.580, 15, 26.120), 矢量(-197.300, 19.650, -0.040), 矢量(-202.870,
				9.100, -0.110), 矢量(-199.420, 15, -25.350), 矢量(-168.600, 20.960, -68.240), 矢量(-198.160, 19.070, -47.690));
			"University goal position"
			全局.EndPosition = 矢量(-188.063, 19.298, -63.705) - 矢量(0, 2, 0);
			全局.ResetRerollRingStats[0] = 矢量(-197.983, 20.350, 81.201);
			"Base coordinates for world game settings HUD"
			全局.GameSettingTextVec = 矢量(-188.171, 20.300, 81.549);
		"Garden"
		Else If(数量(范围内玩家(矢量(203.074, 8.038, -185.630), 40, 队伍1, 关闭)) != 0);
			全局.AllBastionPositions = 数组(矢量(156.995, 11.203, -195.446), 矢量(150.920, 8.675, -231.561), 矢量(131.907, 16.581, -238.408), 矢量(135.660,
				6.680, -230.400), 矢量(123.970, 6.480, -241.520), 矢量(108.870, 13.853, -277.224), 矢量(98.310, 8.960, -264.870));
			"Garden goal position"
			全局.EndPosition = 矢量(71.347, 9.120, -279.602) - 矢量(0, 2, 0);
			"Base coordinates for world game settings HUD"
			全局.GameSettingTextVec = 矢量(192.857, 9.038, -196.085);
			全局.ResetRerollRingStats[0] = 矢量(204.878, 7.247, -199.526);
		"City Center"
		Else If(数量(范围内玩家(矢量(66.241, 2.300, 324.072), 40, 队伍1, 关闭)) != 0);
			全局.AllBastionPositions = 数组(矢量(95.535, 2.200, 272.691), 矢量(143.308, 3.448, 247.397), 矢量(139.550, 11.298, 251.107), 矢量(147.400,
				11.299, 243.810), 矢量(209.108, 2.303, 213.907), 矢量(157.325, 5.232, 213.538), 矢量(173.810, 4.100, 243.860));
			"City Center goal position"
			全局.EndPosition = 矢量(178.628, 2.276, 174.641) - 矢量(0, 2, 0);
			全局.ResetRerollRingStats[0] = 矢量(65.313, 2.300, 314.109);
			"Base coordinates for world game settings HUD"
			全局.GameSettingTextVec = 矢量(84.820, 2.148, 310.593);
		End;
		全局.ResetRerollRingStats[3] = 矢量(0, 0.750, 0);
	}
}

规则("map setting (global arr p, global b, global d, global c) - nepal(all)")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		"Insert map name here"
		当前地图 == 地图(尼泊尔);
	}

	动作
	{
		开始强制重生室(队伍1, 2);
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		等待直到 (对任意为“真”(所有玩家(队伍1), 已重生(当前数组元素)), 99999);
		"Shrine"
		If(数量(范围内玩家(矢量(-41.729, 19.079, -93.923), 30, 队伍1, 关闭)) != 0);
			全局.AllBastionPositions = 数组(矢量(-70.186, 20.076, -40.441), 矢量(-43.379, 19.417, -20.224), 矢量(-43.716, 19.442, 20.212), 矢量(-52.963,
				20.606, 44.634), 矢量(-72.738, 12.476, 47.462), 矢量(-30.099, 16.585, 51.459), 矢量(-73.720, 15.890, 55.110));
			"Shrine goal position"
			全局.EndPosition = 矢量(-45.233, 16.300, 72.137) - 矢量(0, 2, 0);
			全局.ResetRerollRingStats[0] = 矢量(-49.186, 18.079, -89.027);
			"Base coordinates for world game settings HUD"
			全局.GameSettingTextVec = 矢量(-37.556, 18.946, -88.505);
		"Sanctum"
		Else If(数量(范围内玩家(矢量(82.236, 133.730, -90.834), 30, 队伍1, 关闭)) != 0);
			全局.AllBastionPositions = 数组(矢量(92.358, 140.810, -47.405), 矢量(87.229, 136.304, -11.953), 矢量(101.942, 133.200, 17.999), 矢量(98.205,
				137.200, 74.199), 矢量(94.228, 138.254, 47.119), 矢量(67.278, 129.075, 66.450), 矢量(55.640, 129.820, -0.180));
			"Sanctum goal position"
			全局.EndPosition = 矢量(81.480, 131.000, 73.572) - 矢量(0, 2, 0);
			"Base coordinates for world game settings HUD"
			全局.GameSettingTextVec = 矢量(86.482, 133.595, -84.782);
			全局.ResetRerollRingStats[0] = 矢量(75.105, 132.730, -85.197);
		"Village"
		Else If(数量(范围内玩家(矢量(-160.389, -94.271, -84.060), 30, 队伍1, 关闭)) != 0);
			全局.AllBastionPositions = 数组(矢量(-179.755, -88.685, -26.069), 矢量(-204.373, -89.729, -12.570), 矢量(-204.457, -89.727, 12.440), 矢量(
				-195.496, -93.630, 45.155), 矢量(-163.005, -88.821, 43.442), 矢量(-147.271, -83.869, 50.381), 矢量(-211, -92.380, -0.380));
			"Village goal position"
			全局.EndPosition = 矢量(-167.446, -97.633, 68.291) - 矢量(0, 2, 0);
			全局.ResetRerollRingStats[0] = 矢量(-168.919, -95.271, -82.581);
			"Base coordinates for world game settings HUD"
			全局.GameSettingTextVec = 矢量(-159.261, -94.705, -76.760);
		End;
		全局.ResetRerollRingStats[3] = 矢量(0, 1, 0);
	}
}

规则("map setting (global arr p, global b, global d, global c) - ilios(all)")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		"Insert map name here"
		当前地图 == 地图(伊利奥斯);
	}

	动作
	{
		开始强制重生室(队伍1, 2);
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		等待直到 (对任意为“真”(所有玩家(队伍1), 已重生(当前数组元素)), 99999);
		"Well"
		If(数量(范围内玩家(矢量(-152.014, -1.104, -93.120), 30, 队伍1, 关闭)) != 0);
			全局.AllBastionPositions = 数组(矢量(-181.480, 0.300, -50.903), 矢量(-197.571, 11.191, -13.818), 矢量(-223.199, 6.427, 7.091), 矢量(-236.558,
				6.300, -9.246), 矢量(-270.570, 0.440, 42.100), 矢量(-213.939, 3.300, 6.564), 矢量(-241.900, 8.090, 27.160));
			"Well goal position"
			全局.EndPosition = 矢量(-271.140, -3.585, 33.279) - 矢量(0, 2, 0);
			全局.ResetRerollRingStats[0] = 矢量(-160.308, -1.355, -91.403);
			"Base coordinates for world game settings HUD"
			全局.GameSettingTextVec = 矢量(-149.658, -1.587, -86.416);
		"Ruins"
		Else If(数量(范围内玩家(矢量(131.609, 64.254, -159.135), 30, 队伍1, 关闭)) != 0);
			全局.AllBastionPositions = 数组(矢量(91.562, 65.583, -174.582), 矢量(66.927, 68.505, -169.264), 矢量(28.390, 62.689, -148.659), 矢量(-1.205,
				65.524, -147.564), 矢量(-33.746, 65.611, -173.263), 矢量(-65.140, 61.666, -168.727), 矢量(8.130, 63.890, -170.750));
			"Tower goal position"
			全局.EndPosition = 矢量(-51.248, 67.259, -158.371) - 矢量(0, 2, 0);
			"Base coordinates for world game settings HUD"
			全局.GameSettingTextVec = 矢量(127.484, 63.920, -154.025);
			全局.ResetRerollRingStats[0] = 矢量(128.072, 63.254, -165.528);
		"Town"
		Else If(数量(范围内玩家(矢量(322.692, -21.520, 42.832), 30, 队伍1, 关闭)) != 0);
			全局.AllBastionPositions = 数组(矢量(355.021, -19.264, -4.231), 矢量(329.070, -17.640, -29.830), 矢量(350.081, -15.408, -56.854), 矢量(304.817,
				-16.160, -73.229), 矢量(294.106, -19.441, -75.363), 矢量(276.960, -20.361, -83.065), 矢量(334.603, -22.494, -41.438));
			"Town goal position"
			全局.EndPosition = 矢量(290.229, -23.291, -88.556) - 矢量(0, 3, 0);
			全局.ResetRerollRingStats[0] = 矢量(331.080, -21.520, 41.121);
			"Base coordinates for world game settings HUD"
			全局.GameSettingTextVec = 矢量(320.494, -21.755, 36);
		End;
		全局.ResetRerollRingStats[3] = 矢量(0, 0.250, 0);
	}
}

规则("map setting (global arr p, global b, global d, global c) - lijiang tower(all)(lunar new year's)")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		"Insert map name here"
		(当前地图 == 地图(漓江塔) || 当前地图 == 地图(春节漓江塔)) == 真;
	}

	动作
	{
		开始强制重生室(队伍1, 2);
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		等待直到 (对任意为“真”(所有玩家(队伍1), 已重生(当前数组元素)), 99999);
		"Data Center"
		If(数量(范围内玩家(矢量(61.699, 268.879, 342.773), 30, 队伍1, 关闭)) != 0);
			全局.AllBastionPositions = 数组(矢量(30.128, 270.151, 282.442), 矢量(2.043, 280.231, 312.979), 矢量(-0.085, 273.800, 280.044), 矢量(-2.029,
				280.231, 313.200), 矢量(-38.268, 268.300, 295.176), 矢量(-30.740, 270, 339.140), 矢量(-23.080, 271.070, 287.870));
			"Data Center goal position"
			全局.EndPosition = 矢量(-51.280, 266.300, 332.484) - 矢量(0, 2, 0);
			全局.ResetRerollRingStats[0] = 矢量(62.727, 268.878, 334.382);
			"Base coordinates for world game settings HUD"
			全局.GameSettingTextVec = 矢量(54.159, 268.545, 342.362);
		"Tower"
		Else If(数量(范围内玩家(矢量(79.167, 97.863, 144.773), 30, 队伍1, 关闭)) != 0);
			全局.AllBastionPositions = 数组(矢量(46.896, 96.452, 136.808), 矢量(-0.070, 95.551, 158.403), 矢量(0.028, 95.550, 141.938), 矢量(-41.650,
				95.870, 140.950), 矢量(53.242, 97.554, 169.195), 矢量(-54.166, 95.551, 159.799), 矢量(-9.630, 97.770, 149.820));
			"Tower goal position"
			全局.EndPosition = 矢量(-65.245, 95.552, 146.885) - 矢量(0, 2, 0);
			"Base coordinates for world game settings HUD"
			全局.GameSettingTextVec = 矢量(75.006, 97.780, 150.128);
			全局.ResetRerollRingStats[0] = 矢量(74.509, 98.113, 138.469);
		"Shrine"
		Else If(数量(范围内玩家(矢量(78.273, 6.208, -30.659), 30, 队伍1, 关闭)) != 0);
			全局.AllBastionPositions = 数组(矢量(59.390, 2, -14.210), 矢量(-13.990, -0.140, -21.580), 矢量(-0.500, -1, -69.930), 矢量(-30.990, -1, -14),
				矢量(-57.683, 3.745, -12.967), 矢量(-53.844, 4.400, -30.280), 矢量(20.170, 0, -8.920));
			"Shrine goal position"
			全局.EndPosition = 矢量(-60.904, 7.743, -14.404) - 矢量(0, 2, 0);
			全局.ResetRerollRingStats[0] = 矢量(74.792, 5.900, -37.957);
			"Base coordinates for world game settings HUD"
			全局.GameSettingTextVec = 矢量(72.166, 5.786, -26.690);
		End;
		全局.ResetRerollRingStats[3] = 矢量(0, 0, 0);
	}
}

规则("map setting (global arr p, global b, global d, global c) - busan(all)")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		"Insert map name here"
		当前地图 == 地图(釜山);
	}

	动作
	{
		开始强制重生室(队伍1, 2);
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		等待直到 (对任意为“真”(所有玩家(队伍1), 已重生(当前数组元素)), 99999);
		"Factory"
		If(数量(范围内玩家(矢量(290.902, 12.396, 213.099), 30, 队伍1, 关闭)) != 0);
			全局.AllBastionPositions = 数组(矢量(234.970, 16.090, 220.950), 矢量(223.210, 18.040, 212.520), 矢量(51.997, 7.309, -101.671), 矢量(177.838,
				12.395, 275.812), 矢量(186.569, 13.395, 248.653), 矢量(194.799, 22.393, 246.564), 矢量(225.260, 9.150, 248.010));
			"Factory goal position"
			全局.EndPosition = 矢量(163.996, 11.397 - 1.320, 259.067);
			全局.ResetRerollRingStats[0] = 矢量(295.837, 12.494, 218.427);
			"Base coordinates for world game settings HUD"
			全局.GameSettingTextVec = 矢量(295.322, 11.595, 221.749);
		"Plaza"
		Else If(数量(范围内玩家(矢量(-31.724, 18.300, -125.575), 30, 队伍1, 关闭)) != 0);
			全局.AllBastionPositions = 数组(矢量(26.382, 23.990, -110.239), 矢量(36.500, 14.990, -122.660), 矢量(51.761, 7.309, -101.209), 矢量(67.200,
				14.990, -122.720), 矢量(77.047, 24.050, -110.099), 矢量(117.590, 16, -115.980), 矢量(100.080, 23, -135.810));
			"Plaza goal position"
			全局.EndPosition = 矢量(112.557, 17.246 - 1.320, -125.478);
			"Base coordinates for world game settings HUD"
			全局.GameSettingTextVec = 矢量(-43.861, 17.820, -125.438);
			全局.ResetRerollRingStats[0] = 矢量(-43.634, 18.253, -128.069);
		"Dojo"
		Else If(数量(范围内玩家(矢量(-426.165, 12.407, 165.979), 30, 队伍1, 关闭)) != 0);
			全局.AllBastionPositions = 数组(矢量(-365.499, 15.267, 130.545), 矢量(-328.646, 18.403, 167.589), 矢量(-330.120, 14.900, 138.770), 矢量(
				-307.520, 11.953, 139.141), 矢量(-291.570, 13.334, 157.068), 矢量(-252.461, 10.655, 152.426), 矢量(-348.040, 11.010, 142.740));
			"Dojo goal position"
			全局.EndPosition = 矢量(-262.352, 10.460 - 1.320, 161.585);
			全局.ResetRerollRingStats[0] = 矢量(-412.805, 11.462, 154.558);
			"Base coordinates for world game settings HUD"
			全局.GameSettingTextVec = 矢量(-410.566, 11.463, 164.413);
		End;
		全局.ResetRerollRingStats[3] = 矢量(0, 0, 0);
	}
}

规则("map setting (global arr p, global b, global d, global c) - hanamura (winter)")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(当前地图 == 地图(花村) || 当前地图 == 地图(圣诞节花村)) == 真;
	}

	动作
	{
		全局.AllBastionPositions = 数组(矢量(-17.814, 8.859, -86.334), 矢量(-23.327, -1, -47.090), 矢量(13.117, 7.170, -50.253), 矢量(24.812, 6,
			9.457), 矢量(46.742, 6, -13.957), 矢量(68.033, -1.900, 12.950), 矢量(46.743, 1.147, -14.415));
		全局.EndPosition = 矢量(68.166, -2, -0.310);
		开始强制重生室(队伍1, 2);
		"Base coordinates for world game settings HUD"
		全局.GameSettingTextVec = 矢量(-33.825, 1.750, -101.375);
		全局.ResetRerollRingStats[0] = 矢量(-37.960, 0.500, -97.845);
		全局.ResetRerollRingStats[3] = 矢量(0, 2, 0);
	}
}

规则("map setting (global arr p, global b, global d, global c) - gibraltar")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(监测站：直布罗陀);
	}

	动作
	{
		全局.AllBastionPositions = 数组(矢量(70.099, 9, 26.803), 矢量(83.030, 6, 1), 矢量(57.146, 1.068, -22.573), 矢量(35.750, 7.741, -48.903), 矢量(
			30.470, 7.290, -90.220), 矢量(56.883, 10.351, -119.045), 矢量(21.318, 4.249, -64.963));
		全局.EndPosition = 矢量(46.558, 1, -146.808);
		开始强制重生室(队伍1, 2);
		"Base coordinates for world game settings HUD"
		全局.GameSettingTextVec = 矢量(101.203, -0.798, 63.481);
		全局.ResetRerollRingStats[0] = 矢量(103.003, -0.694, 72.610);
	}
}

规则("map setting (global arr p, global b, global d, global c) - volskaya industries")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(沃斯卡娅工业区);
	}

	动作
	{
		全局.AllBastionPositions = 数组(矢量(-87.972, 2.020, 38.919), 矢量(-67.835, 10.390, 49.479), 矢量(-63.809, -0.410, 77.730), 矢量(-11.250,
			1.270, 76.356), 矢量(-16.279, 2.200, 41.017), 矢量(-6.364, 8.240, 35.514), 矢量(-35.430, -2.980, 28.190));
		全局.EndPosition = 矢量(-11.477, -6, 19.868);
		开始强制重生室(队伍1, 0);
		"Base coordinates for world game settings HUD"
		全局.GameSettingTextVec = 矢量(-112.517, -1.680, 32.352);
		全局.ResetRerollRingStats[0] = 矢量(-117.908, -0.680, 36.678);
	}
}

规则("map setting (global arr p, global b, global d, global c) - route 66")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(66号公路);
	}

	动作
	{
		全局.AllBastionPositions = 数组(矢量(-95.624, 12.660, -5.541), 矢量(-38.680, 12.750, -22.136), 矢量(-15.784, 8.540, -12.685), 矢量(36.467,
			2.140, -4.003), 矢量(48.707, 10.110, 25.063), 矢量(26.871, 7.010, 2.468), 矢量(51.140, 2.380, 59.880));
		全局.EndPosition = 矢量(47.956, 5.200, 47.318);
		开始强制重生室(队伍1, 1);
		"Base coordinates for world game settings HUD"
		全局.GameSettingTextVec = 矢量(-108.281, 5.812, -50.656);
		全局.ResetRerollRingStats[0] = 矢量(-108.447, 6, -62.336);
		全局.ResetRerollRingStats[3] = 矢量(0, 0, 0);
	}
}

规则("map setting (global arr p, global b, global d, global c) - rialto")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(里阿尔托);
	}

	动作
	{
		全局.AllBastionPositions = 数组(矢量(-63.638, 6.600, -124.962), 矢量(-16.976, 1.660, -38.459), 矢量(-36.002, 4.750, -77.344), 矢量(59.058,
			0.070, -8.103), 矢量(54.797, 1.740, -59.938), 矢量(87.874, -0.370, 0.268), 矢量(13.670, 3.750, -35.720));
		全局.EndPosition = 矢量(98.662, -1.500, -21.009);
		开始强制重生室(队伍1, 2);
		"Base coordinates for world game settings HUD"
		全局.GameSettingTextVec = 矢量(-57, 4.050, -156.838);
		全局.ResetRerollRingStats[0] = 矢量(-56.953, 5.500, -167.740);
	}
}

规则("map setting (global arr p, global b, global d, global c) - horizon lunar colony")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(“地平线”月球基地);
	}

	动作
	{
		全局.AllBastionPositions = 数组(矢量(-15.287, 6, -127.244), 矢量(15.270, 11.860, -105.480), 矢量(69.330, 15.200, -75), 矢量(62.340, 6,
			-34.740), 矢量(45.330, 7, -13.350), 矢量(66.687, 8.520, -37.241), 矢量(18.170, 13.630, -33.850));
		全局.EndPosition = 矢量(16.404, 8, -11.343);
		开始强制重生室(队伍1, 0);
		"Base coordinates for world game settings HUD"
		全局.GameSettingTextVec = 矢量(-43.492, 5.800, -156.776);
		全局.ResetRerollRingStats[0] = 矢量(-38.639, 6.450, -165.470);
	}
}

规则("map setting (global arr p, global b, global d, global c) - havana")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(哈瓦那);
	}

	动作
	{
		全局.AllBastionPositions = 数组(矢量(117.332, 14.433, -58.091), 矢量(132.790, 7.980, -37.470), 矢量(31.288, 18.900, -75.331), 矢量(-32.514,
			7.150, -79.487), 矢量(14.787, 7.300, -47.470), 矢量(-62.460, 6.880, -55.300), 矢量(43.730, 9.380, -74.040));
		全局.EndPosition = 矢量(-71.203, 2, -50.678);
		开始强制重生室(队伍1, 2);
		"Base coordinates for world game settings HUD"
		全局.GameSettingTextVec = 矢量(158.050, 12.302, -46.921);
		全局.ResetRerollRingStats[0] = 矢量(172.695, 12.300, -41.247);
	}
}

规则("map setting (global arr p, global b, global d, global c) - dorado")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(多拉多);
	}

	动作
	{
		全局.AllBastionPositions = 数组(矢量(170.288, 19.100, 45.051), 矢量(118.262, 18.250, 1.209), 矢量(78.973, 17.480, -6.843), 矢量(54.110, 9.670,
			-22.990), 矢量(26.361, 10.650, 20.115), 矢量(126.713, 16.300, 17.517), 矢量(21.563, 12.210, -22.421));
		全局.EndPosition = 矢量(16.012, 空数组, 5.874);
		开始强制重生室(队伍1, 1);
		"Base coordinates for world game settings HUD"
		全局.GameSettingTextVec = 矢量(184.096, 7.840, 40.671);
		全局.ResetRerollRingStats[0] = 矢量(183.660, 8.390, 37.902);
	}
}

规则("map setting (global arr p, global b, global d, global c) - king's row (winter)")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(当前地图 == 地图(国王大道) || 当前地图 == 地图(圣诞节国王大道)) == 真;
	}

	动作
	{
		全局.AllBastionPositions = 数组(矢量(-143.900, 7.130, 10.150), 矢量(-123.137, 2.531, -10.074), 矢量(-91.380, 1.140, -27.900), 矢量(-53.630,
			-0.260, -34.810), 矢量(-1.190, 5.490, -2.990), 矢量(-25.200, 3.280, 19.240), 矢量(-28.340, 6, -43.440));
		全局.EndPosition = 矢量(-24.738, 5.800, -0.384);
		开始强制重生室(队伍1, 1);
		"Base coordinates for world game settings HUD"
		全局.GameSettingTextVec = 矢量(-173.483, 0.762, 36.414);
		全局.ResetRerollRingStats[0] = 矢量(-180.556, 1.262, 30.807);
	}
}

规则("map setting (global arr p, global b, global d, global c) - blizzworld (winter)")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(当前地图 == 地图(暴雪世界) || 当前地图 == 地图(圣诞节暴雪世界)) == 真;
	}

	动作
	{
		全局.AllBastionPositions = 数组(矢量(-121.979, 0.148, 110.507), 矢量(-102.650, 4.760, 129.040), 矢量(-62.720, 5.970, 103.820), 矢量(5, 10.180,
			81.370), 矢量(-5.890, 5.940, 48.060), 矢量(3.120, -1.800, -6.850), 矢量(-30.574, 12.966, 87.938));
		开始强制重生室(队伍1, 1);
		全局.EndPosition = 矢量(2.772, -6.500, -6.900);
		"Base coordinates for world game settings HUD"
		全局.GameSettingTextVec = 矢量(-151.769, 1.648, 101.924);
		全局.BlizzWorldSpawnLoc = 矢量(-169.871, 2.948, 96.498);
		全局.ResetRerollRingStats[0] = 矢量(-149.672, 1.544, 97.177);
	}
}

规则("map setting (global arr p, global b, global d, global c) - eichenwalde (halloween)")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(当前地图 == 地图(艾兴瓦尔德) || 当前地图 == 地图(万圣节艾兴瓦尔德)) == 真;
	}

	动作
	{
		全局.AllBastionPositions = 数组(矢量(123.333, 8.971, -27.303), 矢量(89.318, 21.095, -62.697), 矢量(38.021, 13.917, -79.821), 矢量(23.799,
			7.417, -53.839), 矢量(-4.858, 6.957, -31.559), 矢量(25.587, 6.300, -14.531), 矢量(1, 5.830, -61.540));
		全局.EndPosition = 矢量(-10.354, -2.149, -12.399);
		开始强制重生室(队伍1, 2);
		"Base coordinates for world game settings HUD"
		全局.GameSettingTextVec = 矢量(129.339, 12.120, -2.655);
		全局.ResetRerollRingStats[0] = 矢量(124.359, 11.898, 0.626);
	}
}

规则("map setting (global arr p, global b, global d, global c) - hollywood (halloween)")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(当前地图 == 地图(好莱坞) || 当前地图 == 地图(万圣节好莱坞)) == 真;
	}

	动作
	{
		全局.AllBastionPositions = 数组(矢量(-26.166, 7.503, -134.609), 矢量(-2.241, 12.161, -112.505), 矢量(11.552, 6.303, -69.943), 矢量(-7.480,
			7.441, -43.441), 矢量(-20.714, 8.050, 9.977), 矢量(4.864, 7.147, 38.401), 矢量(7.960, 2, 58.700));
		开始强制重生室(队伍1, 2);
		全局.EndPosition = 矢量(-12.002, -1.307, 69.489);
		"Base coordinates for world game settings HUD"
		全局.GameSettingTextVec = 矢量(-32.049, 4.714, -155.052);
		全局.HollywoodSpawnLoc = 矢量(-30.960, 7.254, -172.189);
		全局.BadHollywoodSpawnLoc = 矢量(49.257, 4.050, -56.238);
		全局.ResetRerollRingStats[0] = 矢量(-22.370, 5.416, -158.670);
	}
}

规则("map setting (global arr p, global b, global d, global c) - junkertown")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(渣客镇);
	}

	动作
	{
		全局.AllBastionPositions = 数组(矢量(-94.585, 9.545, -107.597), 矢量(-72.200, 6.370, -145.580), 矢量(-27.431, 13.780, -100.155), 矢量(-7.730,
			9.240, -35.230), 矢量(-1.521, 12.266, -63.511), 矢量(42.540, 16.920, -78.820), 矢量(23.459, 12.337, -70.826));
		全局.EndPosition = 矢量(30.248, 5.515, -81.733);
		开始强制重生室(队伍1, 2);
		"Base coordinates for world game settings HUD"
		全局.GameSettingTextVec = 矢量(-95.486, 12.245, -86.316);
		全局.ResetRerollRingStats[0] = 矢量(-94.717, 11.800, -84.011);
		全局.ResetRerollRingStats[3] = 矢量(0, 0, 0);
	}
}

规则("map setting (global arr p, global b, global d, global c) - paris")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(巴黎);
	}

	动作
	{
		全局.AllBastionPositions = 数组(矢量(-95.984, 13.454, -83.535), 矢量(-72.132, 11.976, -44.042), 矢量(-41.725, 14.240, -2.920), 矢量(14.479,
			11.755, -39.518), 矢量(-14.721, 14.250, -35.219), 矢量(0.211, 10.174, -60.874), 矢量(-16.140, 14.080, -46.600));
		全局.EndPosition = 矢量(9.563, 8.329, -59.980);
		开始强制重生室(队伍1, 1);
		"Base coordinates for world game settings HUD"
		全局.GameSettingTextVec = 矢量(-108.617, 15.800, -109.835);
		全局.ResetRerollRingStats[0] = 矢量(-104.076, 16.445, -109.313);
	}
}

规则("map setting (global arr p, global b, global d, global c) - anubis")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		当前地图 == 地图(阿努比斯神殿);
	}

	动作
	{
		全局.AllBastionPositions = 数组(矢量(-17.188, 11.237, 105.646), 矢量(-12.218, 10.667, 52.835), 矢量(-58.847, 6.810, 41.419), 矢量(-8.454,
			1.153, 29.868), 矢量(8.482, 4.898, 10.299), 矢量(-23.218, 2.706, -26.863), 矢量(-8.047, 6.873, 60.153));
		全局.EndPosition = 矢量(-0.866, -3.781, -10.919);
		开始强制重生室(队伍1, 1);
		"Base coordinates for world game settings HUD"
		全局.GameSettingTextVec = 矢量(-7.971, 5.570, 135.900);
		全局.ResetRerollRingStats[0] = 矢量(-15.733, 5.585, 137.884);
	}
}

规则("Spawn players at alternate spawn location[SR]")
{
	事件
	{
		子程序;
		SpawnAtAltLoc;
	}

	动作
	{
		If(!事件玩家.IsWinner);
			If(当前地图 == 地图(暴雪世界) || 当前地图 == 地图(圣诞节暴雪世界));
				传送(事件玩家, 全局.BlizzWorldSpawnLoc);
				设置朝向(事件玩家, 前 + 左, 至地图);
			Else If(当前地图 == 地图(好莱坞) || 当前地图 == 地图(万圣节好莱坞));
				传送(事件玩家, 全局.HollywoodSpawnLoc);
				设置朝向(事件玩家, 右, 至地图);
			End;
	}
}

规则("Place Player away from bad Blizz World spawn (NEW SPAWN FIX)")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(当前地图 == 地图(暴雪世界) || 当前地图 == 地图(圣诞节暴雪世界)) == 真;
		对任意为“真”(范围内玩家(矢量(-78.650, -0.250, 175.310), 8, 队伍1, 关闭), !当前数组元素.IsWinner && 存活(当前数组元素)) == 真;
	}

	动作
	{
		传送(已过滤的数组(范围内玩家(矢量(-78.650, -0.250, 175.310), 8, 队伍1, 关闭), !当前数组元素.IsWinner), 全局.BlizzWorldSpawnLoc);
	}
}

规则("Place Player away from bad Hollywood spawn (NEW SPAWN FIX)")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		(当前地图 == 地图(好莱坞) || 当前地图 == 地图(万圣节好莱坞)) == 真;
		对任意为“真”(范围内玩家(矢量(50.060, 2.750, -54.900), 7, 队伍1, 关闭), !当前数组元素.IsWinner && 存活(当前数组元素)) == 真;
	}

	动作
	{
		传送(已过滤的数组(范围内玩家(矢量(50.060, 2.750, -54.900), 7, 队伍1, 关闭), !当前数组元素.IsWinner), 全局.HollywoodSpawnLoc);
	}
}

规则("Game settings world HUD")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		等待直到 (对任意为“真”(所有玩家(队伍1), 已重生(当前数组元素)), 99999);
		调用子程序(SetupGameSettingsText);
		For 全局变量(TempVar, 数量(全局.GameSettingsHUDWT) - 1, -1, -1);
			创建地图文本(所有玩家(队伍1), 全局.GameSettingsHUDWT[全局.TempVar], 全局.GameOptTextVec, 1.500, 根据表面截取, 可见, 颜色(灰绿色), 默认可见度);
			调用子程序(IncrementGameSettingsPos);
		End;
		"World game settings HUD"
		创建地图文本(所有玩家(队伍1), 自定义字符串("PRISON ESCAPE"), 全局.GameSettingTextVec, 2.750, 根据表面截取, 可见, 颜色(玫红), 默认可见度);
	}
}

规则("setup game option settings text for world HUD [SR]")
{
	事件
	{
		子程序;
		SetupGameSettingsText;
	}

	动作
	{
		全局.GameSettingsHUDWT = 空数组;
		修改全局变量(GameSettingsHUDWT, 添加至数组, 自定义字符串("Hero Escape Limit: [{0}]", 全局.HeroEscapeLimitWS == 0 ? 自定义字符串("None") : (
			全局.HeroEscapeLimitWS == 1 ? 自定义字符串("Classic (34)") : 自定义字符串("Blitz (16)"))));
		修改全局变量(GameSettingsHUDWT, 添加至数组, 自定义字符串("Backtrack Range: [{0}] <-----> [{1}]", 全局.BacktrackMinMaxListWS[0],
			全局.BacktrackMinMaxListWS[1]));
		全局.GameOptTextVec = 全局.GameSettingTextVec;
		"Height of \"Game Setting\" title"
		全局.GameSettingTextVec += 矢量(0, 0.150, 0);
		"The \"Next Map Cycle Option\""
		If(全局.WinnerCountToCycleWS != 0);
			创建地图文本(所有玩家(队伍1), 自定义字符串("WInners Until Next Map: [{0}] / [{1}]", 全局.CurWinnerCount, 全局.WinnerCountToCycleWS), 全局.GameOptTextVec,
				1.500, 根据表面截取, 可见和字符串, 颜色(黄色), 默认可见度);
			调用子程序(IncrementGameSettingsPos);
		End;
	}
}

规则("Increment game settings HUD position[SR]")
{
	事件
	{
		子程序;
		IncrementGameSettingsPos;
	}

	动作
	{
		"The spacing between each game setting in the HUD"
		全局.GameOptTextSpacing = 矢量(0, 0.600, 0);
		全局.GameOptTextVec += 全局.GameOptTextSpacing;
		全局.GameSettingTextVec += 全局.GameOptTextSpacing;
	}
}

规则("init rings (RINGS)")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.ResetRerollRingStats[2] == 空;
	}

	动作
	{
		等待直到 (对任意为“真”(所有玩家(队伍1), 已重生(当前数组元素)), 99999);
		创建效果(所有玩家(队伍1), 环, 颜色(玫红), 全局.ResetRerollRingStats[0], 全局.ResetRerollRingStats[1], 可见);
		全局.ResetRerollRingStats[2] = 最后创建的实体;
		创建地图文本(所有玩家(队伍1), 自定义字符串("[{0}] Reroll/Reset", 输入绑定字符串(按钮(互动))), 全局.ResetRerollRingStats[0] + 全局.ResetRerollRingStats[3], 1.300,
			根据表面截取, 可见和字符串, 颜色(白色), 默认可见度);
	}
}

规则("Reroll/Reset player (RINGS)")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.ResetRerollRingStats[2] != 空;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		对任意为“真”(范围内玩家(全局.ResetRerollRingStats[0], 全局.ResetRerollRingStats[1], 队伍1, 关闭), 当前数组元素 == 事件玩家) == 真;
	}

	动作
	{
		事件玩家.BacktrackDeaths = 0;
		事件玩家.IsWinner = 假;
		事件玩家.Deaths = 0;
		事件玩家.CurrentHero = 0;
		事件玩家.TargetHero = 0;
		停止强制设置玩家轮廓(事件玩家, 所有玩家(队伍1));
		设置移动速度(事件玩家, 100);
		调用子程序(SliceIndieHeroList);
		等待(0.250, 无视条件);
		小字体信息(事件玩家, 自定义字符串("Wait 10s before trying again..."));
		等待(10, 无视条件);
	}
}

规则("Buff positions (Default) (Global T, Global J)")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.T = 空数组;
		全局.JumpPadLocList = 空数组;
		全局.JumpPadPowerList = 空数组;
		全局.Y = -1;
	}
}

规则("Activate teleporters if spawn room doors is inaccessible - hollywood")
{
	事件
	{
		玩家加入比赛;
		队伍1;
		栏位 0;
	}

	条件
	{
		(当前地图 == 地图(好莱坞) || 当前地图 == 地图(万圣节好莱坞)) == 真;
		相距距离(事件玩家, 全局.BadHollywoodSpawnLoc) <= 15;
	}

	动作
	{
		"Sometimes, the doors to spawn room 3 would be closed. These actions will force the players inside the room. The teleporters will allow players to leave the room at will."
		全局.isTeleporterEnabled = 真;
		调用子程序(SpawnAtAltLoc);
	}
}

规则("Teleporter position init (global T) - paraiso")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.T == 空数组;
		当前地图 == 地图(帕拉伊苏);
	}

	动作
	{
		"Even indexes (0, 2, ...)  are portal senders. Odd indexes (1, 3, ...) are portal receivers. Example: 0 index sends players to 1 index position."
		全局.T = 数组(矢量(-24.323, 7.308, -83.925), 矢量(-18.178, 12.300, -56.841));
	}
}

规则("Teleporter position init (global T) - circuit royal")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.T == 空数组;
		当前地图 == 地图(皇家赛道);
	}

	动作
	{
		"Even indexes (0, 2, ...)  are portal senders. Odd indexes (1, 3, ...) are portal receivers. Example: 0 index sends players to 1 index position."
		全局.T = 数组(矢量(70.716, 19.260, 64.689), 矢量(55.896, 18.373, 48.632), 矢量(48.250, 18.353, 3.740), 矢量(58.953, 16.508, 17.386));
	}
}

规则("Teleporter position init (global T) - nepal")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.T == 空数组;
		当前地图 == 地图(尼泊尔);
	}

	动作
	{
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		等待直到 (对任意为“真”(所有玩家(队伍1), 已重生(当前数组元素)), 99999);
		"Village"
		If(数量(范围内玩家(矢量(-160.389, -94.271, -84.060), 30, 队伍1, 关闭)) != 0);
			"Even indexes (0, 2, ...)  are portal senders. Odd indexes (1, 3, ...) are portal receivers. Example: 0 index sends players to 1 index position."
			全局.T = 数组(矢量(-220.003, -94.746, -24.949), 矢量(-220.392, -93.377, -10.542), 矢量(-220.104, -94.205, 13.117), 矢量(-220.205, -94.747,
				25.866));
		"Sanctum"
		Else If(数量(范围内玩家(矢量(82.236, 133.730, -90.834), 30, 队伍1, 关闭)) != 0);
			"Even indexes (0, 2, ...)  are portal senders. Odd indexes (1, 3, ...) are portal receivers. Example: 0 index sends players to 1 index position."
			全局.T = 数组(矢量(96.787, 129.300, -0.132), 矢量(105.339, 133.942, 32.889));
	}
}

规则("Teleporter position init (global T) - hollywood")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.T == 空数组;
		全局.isTeleporterEnabled == 真;
		(当前地图 == 地图(好莱坞) || 当前地图 == 地图(万圣节好莱坞)) == 真;
	}

	动作
	{
		"Even indexes (0, 2, ...)  are portal senders. Odd indexes (1, 3, ...) are portal receivers. Example: 0 index sends players to 1 index position."
		全局.T = 数组(矢量(-52.836, 5.050, -148.546), 矢量(-52.562, 5.050, -147.402), 矢量(-14.796, 5.050, -147.334), 矢量(-15.813, 5.050, -146.567));
	}
}

规则("Teleporter position init (global T) - illios")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.T == 空数组;
		当前地图 == 地图(伊利奥斯);
	}

	动作
	{
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		等待直到 (对任意为“真”(所有玩家(队伍1), 已重生(当前数组元素)), 99999);
		"Well"
		If(数量(范围内玩家(矢量(-152.014, -1.104, -93.120), 30, 队伍1, 关闭)) != 0);
			"Even indexes (0, 2, ...)  are portal senders. Odd indexes (1, 3, ...) are portal receivers. Example: 0 index sends players to 1 index position."
			全局.T = 数组(矢量(-219.430, 1.300, -22.312), 矢量(-199.053, 2.315, -6.979), 矢量(-196.207, 2.315, -4.372), 矢量(-214.369, 1.300, -26.572));
		"Ruins"
		Else If(数量(范围内玩家(矢量(131.609, 64.254, -159.135), 30, 队伍1, 关闭)) != 0);
			"Even indexes (0, 2, ...)  are portal senders. Odd indexes (1, 3, ...) are portal receivers. Example: 0 index sends players to 1 index position."
			全局.T = 数组(矢量(59.421, 61.917, -140.094), 矢量(41.130, 67.671, -144.216), 矢量(-1.989, 61.668, -167.644), 矢量(-0.496, 65.784, -170.078));
	}
}

规则("Teleporter position init (global T) - hanamura (winter)")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.T == 空数组;
		(当前地图 == 地图(花村) || 当前地图 == 地图(圣诞节花村)) == 真;
	}

	动作
	{
		"Even indexes (0, 2, ...)  are portal senders. Odd indexes (1, 3, ...) are portal receivers. Example: 0 index sends players to 1 index position."
		全局.T = 数组(矢量(-28.532, 2.301, -57.827), 矢量(-12.406, 2.299, -32.859), 矢量(26.500, 1.200, 7.857), 矢量(46.023, 1.768, 38.157));
	}
}

规则("Teleporter position init (global T) - king's row")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.T == 空数组;
		(当前地图 == 地图(国王大道) || 当前地图 == 地图(圣诞节国王大道)) == 真;
	}

	动作
	{
		"Even indexes (0, 2, ...)  are portal senders. Odd indexes (1, 3, ...) are portal receivers. Example: 0 index sends players to 1 index position."
		全局.T = 数组(矢量(-19.893, 1.274, 23.138), 矢量(-26.658, 9.200, 10.300));
	}
}

规则("Jump pad position init (global J)(global K) - shambali monastery")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.JumpPadLocList == 空数组;
		当前地图 == 地图(香巴里寺院);
	}

	动作
	{
		"The location of the jump pad"
		修改全局变量(JumpPadLocList, 添加至数组, 矢量(-19.179, 11.300, 38.193));
		"The strength of the jump pad. How high to to bounce players upwards?"
		修改全局变量(JumpPadPowerList, 添加至数组, 16);
		"The location of the jump pad"
		修改全局变量(JumpPadLocList, 添加至数组, 矢量(5.232, 7.485, 3.430));
		"The strength of the jump pad. How high to to bounce players upwards?"
		修改全局变量(JumpPadPowerList, 添加至数组, 18);
	}
}

规则("Jump pad position init (global J)(global K) - paraiso")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.JumpPadLocList == 空数组;
		当前地图 == 地图(帕拉伊苏);
	}

	动作
	{
		"The location of the jump pad"
		修改全局变量(JumpPadLocList, 添加至数组, 矢量(12.278, 1.315, -55.306));
		"The strength of the jump pad. How high to to bounce players upwards?"
		修改全局变量(JumpPadPowerList, 添加至数组, 12);
		"The location of the jump pad"
		修改全局变量(JumpPadLocList, 添加至数组, 矢量(-15.973, 2.139, -32.170));
		"The strength of the jump pad. How high to to bounce players upwards?"
		修改全局变量(JumpPadPowerList, 添加至数组, 18);
	}
}

规则("Jump pad position init (global J)(global K) - circuit royal")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.JumpPadLocList == 空数组;
		当前地图 == 地图(皇家赛道);
	}

	动作
	{
		"The location of the jump pad"
		修改全局变量(JumpPadLocList, 添加至数组, 矢量(-24.858, 7.264, 1.876));
		"The strength of the jump pad. How high to to bounce players upwards?"
		修改全局变量(JumpPadPowerList, 添加至数组, 14);
	}
}

规则("Jump pad position init (global J) - havana")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.JumpPadLocList == 空数组;
		当前地图 == 地图(哈瓦那);
	}

	动作
	{
		修改全局变量(JumpPadLocList, 添加至数组, 矢量(103.926, 3.104, -25.884));
		修改全局变量(JumpPadPowerList, 添加至数组, 18);
	}
}

规则("Jump pad position init (global J)(global K) - nepal")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.JumpPadLocList == 空数组;
		当前地图 == 地图(尼泊尔);
	}

	动作
	{
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		等待直到 (对任意为“真”(所有玩家(队伍1), 已重生(当前数组元素)), 99999);
		"Shrine"
		If(数量(范围内玩家(矢量(-41.729, 19.079, -93.923), 30, 队伍1, 关闭)) != 0);
			"The location of the jump pad"
			修改全局变量(JumpPadLocList, 添加至数组, 矢量(-27.684, 16.779, -62.910));
			"The strength of the jump pad. How high to to bounce players upwards?"
			修改全局变量(JumpPadPowerList, 添加至数组, 16);
			"The location of the jump pad"
			修改全局变量(JumpPadLocList, 添加至数组, 矢量(-45.142, 16.300, -60.279));
			"The strength of the jump pad. How high to to bounce players upwards?"
			修改全局变量(JumpPadPowerList, 添加至数组, 12);
			"The location of the jump pad"
			修改全局变量(JumpPadLocList, 添加至数组, 矢量(-28.223, 16.467, 65.481));
			"The strength of the jump pad. How high to to bounce players upwards?"
			修改全局变量(JumpPadPowerList, 添加至数组, 16);
		"Village"
		Else If(数量(范围内玩家(矢量(-160.389, -94.271, -84.060), 30, 队伍1, 关闭)) != 0);
			"The location of the jump pad"
			修改全局变量(JumpPadLocList, 添加至数组, 矢量(-216.263, -94.689, 24.938));
			"The strength of the jump pad. How high to to bounce players upwards?"
			修改全局变量(JumpPadPowerList, 添加至数组, 12);
			"The location of the jump pad"
			修改全局变量(JumpPadLocList, 添加至数组, 矢量(-194.944, -92.303, -10.583));
			"The strength of the jump pad. How high to to bounce players upwards?"
			修改全局变量(JumpPadPowerList, 添加至数组, 16);
	}
}

规则("Jump pad position init (global J, global K) - hanamura")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.JumpPadLocList == 空数组;
		(当前地图 == 地图(花村) || 当前地图 == 地图(圣诞节花村)) == 真;
	}

	动作
	{
		修改全局变量(JumpPadLocList, 添加至数组, 矢量(33.167, 3, -24.676));
		修改全局变量(JumpPadPowerList, 添加至数组, 18);
	}
}

规则("Jump pad position init (global J)(global K) - illios")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.JumpPadLocList == 空数组;
		当前地图 == 地图(伊利奥斯);
	}

	动作
	{
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		等待直到 (对任意为“真”(所有玩家(队伍1), 已重生(当前数组元素)), 99999);
		"Town"
		If(数量(范围内玩家(矢量(322.692, -21.520, 42.832), 30, 队伍1, 关闭)) != 0);
			"The location of the jump pad"
			修改全局变量(JumpPadLocList, 添加至数组, 矢量(370.190, -27.343, -56.901));
			"The strength of the jump pad. How high to to bounce players upwards?"
			修改全局变量(JumpPadPowerList, 添加至数组, 20);
		"Well"
		Else If(数量(范围内玩家(矢量(-152.014, -1.104, -93.120), 30, 队伍1, 关闭)) != 0);
			"The location of the jump pad"
			修改全局变量(JumpPadLocList, 添加至数组, 矢量(-230.206, 0.300, -32.998));
			"The strength of the jump pad. How high to to bounce players upwards?"
			修改全局变量(JumpPadPowerList, 添加至数组, 16);
			"The location of the jump pad"
			修改全局变量(JumpPadLocList, 添加至数组, 矢量(-224.623, 0.300, -38.636));
			"The strength of the jump pad. How high to to bounce players upwards?"
			修改全局变量(JumpPadPowerList, 添加至数组, 16);
			"The location of the jump pad"
			修改全局变量(JumpPadLocList, 添加至数组, 矢量(-198.022, 2.300, 5.441));
			"The strength of the jump pad. How high to to bounce players upwards?"
			修改全局变量(JumpPadPowerList, 添加至数组, 16);
			"The location of the jump pad"
			修改全局变量(JumpPadLocList, 添加至数组, 矢量(-218.367, 6.529, 15.425));
			"The strength of the jump pad. How high to to bounce players upwards?"
			修改全局变量(JumpPadPowerList, 添加至数组, 12);
		"Ruins"
		Else If(数量(范围内玩家(矢量(131.609, 64.254, -159.135), 30, 队伍1, 关闭)) != 0);
			"The location of the jump pad"
			修改全局变量(JumpPadLocList, 添加至数组, 矢量(77.862, 60.082, -171.666));
			"The strength of the jump pad. How high to to bounce players upwards?"
			修改全局变量(JumpPadPowerList, 添加至数组, 16);
			"The location of the jump pad"
			修改全局变量(JumpPadLocList, 添加至数组, 矢量(-49.604, 61.667, -178.331));
			"The strength of the jump pad. How high to to bounce players upwards?"
			修改全局变量(JumpPadPowerList, 添加至数组, 14);
			"The location of the jump pad"
			修改全局变量(JumpPadLocList, 添加至数组, 矢量(-56.603, 66.734, -171.348));
			"The strength of the jump pad. How high to to bounce players upwards?"
			修改全局变量(JumpPadPowerList, 添加至数组, 14);
	}
}

规则("disable ult")
{
	事件
	{
		玩家阵亡;
		双方;
		全部;
	}

	动作
	{
		禁用按钮(事件玩家, 按钮(终极技能));
	}
}

规则("bastion enable turret mode")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		已重生(事件玩家) == 真;
		存活(事件玩家) == 真;
		正在使用技能 1(事件玩家) == 假;
	}

	动作
	{
		可用按钮(事件玩家, 按钮(技能1));
		按下按键(事件玩家, 按钮(技能1));
		等待(0.032, 无视条件);
		如条件为“真”则循环;
	}
}

规则("bastion teleport and init (player E, global d)")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		存活(事件玩家) == 真;
		已重生(事件玩家) == 真;
	}

	动作
	{
		等待(0.250, 无视条件);
		传送(事件玩家, 全局.AllBastionPositions[栏位(事件玩家)]);
		设置状态(事件玩家, 空, 无敌, 99999);
		事件玩家.E = 0;
		设置造成伤害(事件玩家, 200);
		设置受到的击退(事件玩家, 1);
	}
}

规则("teleport bastions back")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		相距距离(事件玩家, 全局.AllBastionPositions[栏位(事件玩家)]) > 2;
	}

	动作
	{
		传送(事件玩家, 全局.AllBastionPositions[栏位(事件玩家)]);
		等待(0.100, 无视条件);
		如条件为“真”则循环;
	}
}

规则("winner effects on reach to end")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		事件玩家.IsWinner != 真;
		Y方向分量(所选位置(事件玩家)) >= Y方向分量(全局.EndPosition);
		相距距离(事件玩家, 矢量(X方向分量(全局.EndPosition), Y方向分量(所选位置(事件玩家)), Z方向分量(全局.EndPosition))) <= 4;
	}

	动作
	{
		复生(事件玩家);
		等待(0.032, 无视条件);
		If(事件玩家.CurrentHero < 数量(事件玩家.IndieHeroList) && 事件玩家.CurrentHero == 事件玩家.TargetHero);
			事件玩家.CurrentHero += 1;
			事件玩家.TargetHero = 事件玩家.CurrentHero;
		End;
		事件玩家.BacktrackDeaths = 0;
		If(事件玩家.CurrentHero == 数量(事件玩家.IndieHeroList));
			事件玩家.IsWinner = 真;
			根据条件跳过(全局.WinnerCountToCycleWS == 0, 1);
			全局.CurWinnerCount += 1;
			大字体信息(所有玩家(队伍1), 自定义字符串("{0} escapes with {1} deaths!!!", 事件玩家, 事件玩家.Deaths));
		End;
		播放效果(所有玩家(队伍1), 状态爆炸声音, 颜色(白色), 事件玩家, 200);
		调用子程序(SpawnAtAltLoc);
	}
}

规则("goal effects")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		创建效果(所有玩家(队伍1), 环, 颜色(队伍1), 全局.EndPosition, 4, 可见，位置和半径);
		创建效果(所有玩家(队伍1), 光柱, 颜色(队伍1), 全局.EndPosition, 4, 可见，位置和半径);
		创建图标(所有玩家(所有队伍), 全局.EndPosition + 矢量(空数组, 5, 空数组), 旗帜, 可见和位置, 颜色(蓝色), 真);
	}
}

规则("no damage for team 1")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
	}

	动作
	{
		设置造成伤害(事件玩家, 0);
	}
}

规则("player hud")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.IsDebugMode == 假;
	}

	动作
	{
		创建HUD文本(事件玩家, 英雄图标字符串(事件玩家.IndieHeroList[事件玩家.TargetHero + 1]), 自定义字符串("Next Hero"), 事件玩家.IndieHeroList[事件玩家.TargetHero + 1], 左边,
			2, 颜色(蓝色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(事件玩家, 字符串("{0}：{1}", 字符串("英雄"), !事件玩家.IsWinner ? 字符串("{0} / {1}", 事件玩家.CurrentHero + 1, 数量(事件玩家.IndieHeroList)) : 自定义字符串(
			"Done!")), 空, 空, 左边, 0, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		创建HUD文本(事件玩家, 自定义字符串("Backtrack Deaths: {0}/{1}", 事件玩家.BacktrackDeaths, 全局.BacktrackDeathsWS), 空, 空, 左边, 1, 颜色(红色), 颜色(白色), 颜色(白色),
			可见和字符串, 默认可见度);
		隐藏计分板(事件玩家);
		隐藏消灭提示(事件玩家);
		事件玩家.PlayerProgressVisibility = 所有玩家(队伍1);
		创建地图文本(事件玩家.PlayerProgressVisibility, 自定义字符串("{0} {1}", 事件玩家.IsWinner ? 图标字符串(骷髅) : 图标字符串(黑桃),
			事件玩家.IsWinner ? 事件玩家.Deaths : 事件玩家.CurrentHero + 1), 眼睛位置(事件玩家) + 矢量(0, 0.600, 0), 1, 根据表面截取, 可见，位置，字符串和颜色, 事件玩家.IsWinner ? 颜色(
			绿色) : 颜色(青绿色), 默认可见度);
	}
}

规则("Show current stats to players (Player Progress)")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.IsWinner == 假;
		生命值(事件玩家) == 最大生命值(事件玩家);
	}

	动作
	{
		隐藏姓名板(事件玩家, 所有玩家(队伍1));
		事件玩家.PlayerProgressVisibility = 所有玩家(队伍1);
	}
}

规则("Hide current stats to players (Player Progress)")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.IsWinner == 假;
		生命值(事件玩家) < 最大生命值(事件玩家);
	}

	动作
	{
		显示姓名板(事件玩家, 所有玩家(队伍1));
		事件玩家.PlayerProgressVisibility = 空;
	}
}

规则("disables assembling hero phase *(Midtown)*")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		正在集结英雄 == 真;
		当前地图 == 地图(中城);
	}

	动作
	{
		设置比赛时间(0);
	}
}

规则("prevents bastion's from repeatedly respawning during the beginning of the game *(Midtown)*")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		正在设置 == 真;
		当前地图 == 地图(中城);
	}

	动作
	{
		设置比赛时间(0);
	}
}

规则("infinity game")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		正在设置 == 假;
	}

	动作
	{
		等待(300, 无视条件);
		设置比赛时间(3599);
	}
}

规则("heal")
{
	事件
	{
		玩家受到伤害;
		队伍1;
		全部;
	}

	条件
	{
		存活(事件玩家) == 真;
	}

	动作
	{
		停止所有持续治疗(事件玩家);
		等待(2, 当为“假”时中止);
		播放效果(所有玩家(所有队伍), 正面状态施加声音, 颜色(黄色), 事件玩家, 2);
		开始持续治疗(事件玩家, 事件玩家, 9999, 25);
	}
}

规则("deaths counter")
{
	事件
	{
		玩家阵亡;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.IsWinner == 假;
		攻击方 != 空;
		攻击方 != 事件玩家;
	}

	动作
	{
		事件玩家.Deaths += 1;
		事件玩家.BacktrackDeaths += 1;
	}
}

规则("Backtrack a hero after many deaths")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.IsWinner == 假;
		事件玩家.BacktrackDeaths >= 全局.BacktrackDeathsWS;
	}

	动作
	{
		复生(事件玩家);
		调用子程序(SpawnAtAltLoc);
		事件玩家.BacktrackDeaths = 0;
		If(事件玩家.CurrentHero != 0);
			事件玩家.randBacktrackNum = 随机整数(全局.BacktrackMinMaxListWS[0], 全局.BacktrackMinMaxListWS[1]);
			If(事件玩家.CurrentHero - 事件玩家.randBacktrackNum < 0);
				事件玩家.CurrentHero = 0;
			Else;
				事件玩家.CurrentHero = 事件玩家.CurrentHero - 事件玩家.randBacktrackNum;
			End;
			事件玩家.TargetHero = 事件玩家.CurrentHero;
		End;
		复生(事件玩家);
		等待(3, 无视条件);
		If(事件玩家.CurrentHero == 0);
			小字体信息(事件玩家, 自定义字符串("Backtracked to the very first hero!"));
		Else If(事件玩家.randBacktrackNum == 1);
			小字体信息(事件玩家, 自定义字符串("Backtracked a single hero!"));
		Else If(事件玩家.randBacktrackNum >= 7);
			小字体信息(事件玩家, 自定义字符串("Yikes! Backtracked {0} heroes! Be careful next time!"));
		Else;
			小字体信息(事件玩家, 自定义字符串("Backtracked {0} heroes!", 事件玩家.randBacktrackNum));
		End;
	}
}

规则("Destroy D.Va's mech goal HUD")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		D.Va;
	}

	条件
	{
		处于非初始状态(事件玩家) == 假;
		事件玩家.DVAHUD != 空;
	}

	动作
	{
		调用子程序(DestroyDVAMechHUD);
	}
}

规则("Destroy goal HUD for D.Va mech [SR]")
{
	事件
	{
		子程序;
		DestroyDVAMechHUD;
	}

	动作
	{
		If(事件玩家.DVAHUD != 空);
			等待(0.250, 当为“假”时中止);
			消除HUD文本(事件玩家.DVAHUD);
			事件玩家.DVAHUD = 空;
			If(全局.IsDVADebug == 真);
				修改玩家变量(事件玩家, DVADebugStates, 添加至数组, 自定义字符串("Destroy Mech Goal HUD"));
			End;
	}
}

规则("Create D.Va's goal HUD for mech")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		D.Va;
	}

	条件
	{
		处于非初始状态(事件玩家) == 真;
		事件玩家.DVAHUD == 空;
		存活(事件玩家) == 真;
	}

	动作
	{
		等待(0.250, 当为“假”时中止);
		事件玩家.M = 所选位置(事件玩家) * 矢量(1, 空数组, 1);
		创建HUD文本(事件玩家, 字符串("{0}：{1}", 字符串("{0} {1}", 字符串("目标"), 字符串("距离")), 较大(0, 50 - 相距距离(所选位置(事件玩家) * 矢量(1, 空数组, 1), 事件玩家.M))), 空, 空, 顶部,
			5, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
		事件玩家.DVAHUD = 上一个文本ID;
		If(全局.IsDVADebug == 真);
			修改玩家变量(事件玩家, DVADebugStates, 添加至数组, 自定义字符串("Create Mech Goal HUD"));
		End;
	}
}

规则("if D.Va haven't reached 50 meters yet")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		D.Va;
	}

	条件
	{
		处于非初始状态(事件玩家) == 真;
		在重生室中(事件玩家) == 假;
		事件玩家.DVAHUD != 空;
		相距距离(所选位置(事件玩家) * 矢量(1, 空数组, 1), 事件玩家.M) < 50;
	}

	动作
	{
		设置终极技能充能(事件玩家, 2 * 相距距离(所选位置(事件玩家) * 矢量(1, 空数组, 1), 事件玩家.M));
		等待(0.100, 无视条件);
		如条件为“真”则循环;
		If(全局.IsDVADebug == 真);
			修改玩家变量(事件玩家, DVADebugStates, 添加至数组, 自定义字符串("Not Reached Goal"));
	}
}

规则("If D.Va passes 50 meters")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		D.Va;
	}

	条件
	{
		处于非初始状态(事件玩家) == 真;
		在重生室中(事件玩家) == 假;
		事件玩家.DVAHUD != 空;
		相距距离(所选位置(事件玩家) * 矢量(1, 空数组, 1), 事件玩家.M) >= 50;
	}

	动作
	{
		设置终极技能充能(事件玩家, 100);
		If(全局.IsDVADebug == 真);
			修改玩家变量(事件玩家, DVADebugStates, 添加至数组, 自定义字符串("Reached Goal"));
	}
}

规则("If D.Va calls mech")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		D.Va;
	}

	条件
	{
		处于非初始状态(事件玩家) == 真;
		终极技能充能百分比(事件玩家) == 100;
		事件玩家.DVAHUD != 空;
	}

	动作
	{
		可用按钮(事件玩家, 按钮(终极技能));
		等待(0.400, 无视条件);
		"Automatically place D.Va in her mech if she has her ultimate"
		按下按键(事件玩家, 按钮(终极技能));
		根据条件循环(终极技能充能百分比(事件玩家) == 100);
		禁用按钮(事件玩家, 按钮(终极技能));
		If(全局.IsDVADebug == 真);
			修改玩家变量(事件玩家, DVADebugStates, 添加至数组, 自定义字符串("Mech Called"));
		End;
	}
}

规则("If D.Va respawns in alternative form")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		D.Va;
	}

	条件
	{
		在重生室中(事件玩家) == 真;
		处于非初始状态(事件玩家) == 真;
	}

	动作
	{
		设置终极技能充能(事件玩家, 100);
		If(全局.IsDVADebug == 真);
			修改玩家变量(事件玩家, DVADebugStates, 添加至数组, 自定义字符串("Respawn in Alt form"));
	}
}

禁用 规则("D.Va states (debug)")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		D.Va;
	}

	条件
	{
		全局.IsDebugMode == 真;
	}

	动作
	{
		事件玩家.DVADebugStates = 空数组;
		全局.IsDVADebug = 真;
	}
}

规则("Removes ult gained from D.Va while in mech")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		D.Va;
	}

	条件
	{
		处于非初始状态(事件玩家) == 假;
		终极技能充能百分比(事件玩家) > 0;
	}

	动作
	{
		设置终极技能充能(事件玩家, 0);
	}
}

规则("If D.Va dies")
{
	事件
	{
		玩家阵亡;
		队伍1;
		D.Va;
	}

	动作
	{
		设置移动速度(事件玩家, 0);
		等待(0.300, 无视条件);
		If(存活(事件玩家) && !在重生室中(事件玩家));
			"This extra respawn is important!!! If Baby D.Va dies while getting into her mech, she will be permanently stuck at spawn point unrendered.  "
			复生(事件玩家);
		End;
		If(处于非初始状态(事件玩家) == 真);
			设置终极技能充能(事件玩家, 100);
		Else;
			调用子程序(DestroyDVAMechHUD);
			事件玩家.DVAHUD = 空;
		End;
		设置移动速度(事件玩家, 100);
		If(全局.IsDVADebug == 真);
			修改玩家变量(事件玩家, DVADebugStates, 添加至数组, 自定义字符串("Died"));
	}
}

规则("destroy hud if player is not D.Va anymore")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.DVAHUD != 空;
		所用英雄(事件玩家) != 英雄(D.Va);
	}

	动作
	{
		消除HUD文本(事件玩家.DVAHUD);
		等待(0.032, 无视条件);
		事件玩家.DVAHUD = 空;
	}
}

规则("Create jump pad effects [SR]")
{
	事件
	{
		子程序;
		CreateJumpPads;
	}

	动作
	{
		If(全局.Y < 数量(全局.JumpPadLocList) && 全局.JumpPadLocList != 空数组);
			创建效果(所有玩家(所有队伍), 火花, 颜色(绿色), 全局.JumpPadLocList[全局.Y], 全局.JumpPadRadius, 可见);
	}
}

规则("Create teleport effects [SR]")
{
	事件
	{
		子程序;
		CreateTeleporters;
	}

	动作
	{
		If(全局.Y < 数量(全局.T) && 全局.T != 空数组);
			根据条件跳过(全局.Y % 2 == 0, 1);
			创建效果(所有玩家(所有队伍), 有害光环, 颜色(红色), 全局.T[全局.Y], 1, 可见);
			根据条件跳过(全局.Y % 2 == 1, 1);
			创建效果(所有玩家(所有队伍), 有益光环, 颜色(红色), 全局.T[全局.Y], 1, 可见);
	}
}

规则("Chase Y from 0 to 100 to create effects")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.Y == -1;
	}

	动作
	{
		全局.Y += 1;
		"REQUIRED for control maps (ilios, lijiang tower, nepal, etc)"
		等待直到 (对任意为“真”(所有玩家(队伍1), 已重生(当前数组元素)), 99999);
		调用子程序(CreateJumpPads);
		调用子程序(CreateTeleporters);
		等待(0.100, 无视条件);
		根据条件循环(全局.Y < 100);
	}
}

规则("If player near a portal")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		全局.T != 空数组;
		对任意为“真”(全局.T, 数组值的索引(全局.T, 当前数组元素) % 2 == 0 && 相距距离(当前数组元素, 所选位置(事件玩家)) < 1.500) == 真;
	}

	动作
	{
		事件玩家.W = 首个(已过滤的数组(全局.T, 数组值的索引(全局.T, 当前数组元素) % 2 == 0 && 相距距离(当前数组元素, 所选位置(事件玩家)) < 1.500));
		传送(事件玩家, 全局.T[数组值的索引(全局.T, 事件玩家.W) + 1]);
		播放效果(所有玩家(所有队伍), 正面状态施加声音, 颜色(黄色), 事件玩家, 1);
	}
}

规则("If player near a jump pad")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.JumpPadLocList != 空数组;
		对任意为“真”(全局.JumpPadLocList, 相距距离(当前数组元素, 所选位置(事件玩家)) <= 全局.JumpPadRadius) == 真;
	}

	动作
	{
		施加推力(事件玩家, 上, 全局.JumpPadPowerList[数组值的索引(全局.JumpPadLocList, 首个(已过滤的数组(全局.JumpPadLocList, 相距距离(所选位置(事件玩家), 当前数组元素)
			< 全局.JumpPadRadius)))], 至地图, 取消相反运动);
		播放效果(所有玩家(队伍1), 状态爆炸声音, 颜色(白色), 事件玩家, 50);
	}
}

禁用 规则("no dmg (debug)")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.IsDebugMode == 真;
	}

	动作
	{
		设置状态(事件玩家, 空, 无敌, 9999);
	}
}

禁用 规则("move & projectile speed (debug)")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.IsDebugMode == 真;
	}

	动作
	{
		设置移动速度(事件玩家, 200);
		设置弹道速度(事件玩家, 200);
	}
}

禁用 规则("sphere (debug)")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.IsDebugMode == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
	}

	动作
	{
		创建效果(所有玩家(所有队伍), 球体, 颜色(白色), 所选位置(事件玩家), 20, 无);
	}
}

禁用 规则("All positions (debug)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.IsDebugMode == 真;
	}

	动作
	{
		创建HUD文本(所有玩家(所有队伍), 字符串("{0}：{1}", 事件玩家, 所选位置(事件玩家)), 空, 空, 左边, 0, 颜色(白色), 颜色(白色), 颜色(白色), 可见和字符串, 默认可见度);
	}
}

禁用 规则("======== set debug mode on/off")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.IsDebugMode = 真;
		启用查看器录制;
	}
}

禁用 规则("Init as Winner (debug)")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.IsDebugMode == 真;
	}

	动作
	{
		事件玩家.IsWinner = 真;
	}
}

禁用 规则("Fast Hero (debug)")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		全局.IsDebugMode == 真;
		按钮被按下(事件玩家, 按钮(近身攻击)) == 真;
		主机玩家 == 事件玩家;
	}

	动作
	{
		If(事件玩家.CurrentHero < 数量(全部英雄));
			事件玩家.CurrentHero += 1;
			事件玩家.TargetHero = 事件玩家.CurrentHero;
			等待(0.625, 无视条件);
	}
}

规则("Add Bastion Bots")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		数量(所有玩家(队伍2)) < 数量(全局.AllBastionPositions);
	}

	动作
	{
		生成机器人(英雄(堡垒), 队伍2, -1, 数组随机取值(重生点(队伍2)), 左 - 左);
		等待(0.250, 无视条件);
		如条件为“真”则循环;
	}
}

规则("No Hud & apply winner outline")
{
	事件
	{
		玩家加入比赛;
		队伍1;
		全部;
	}

	动作
	{
		隐藏游戏模式HUD(事件玩家);
		"Enable Custom PRISON ESCAPE Respawning"
		关闭游戏预设复生模式(事件玩家);
		If(对任意为“真”(所有玩家(队伍1), 当前数组元素.IsWinner));
			开始强制设置玩家轮廓(已过滤的数组(所有玩家(队伍1), 当前数组元素.IsWinner), 所有玩家(队伍1), 真, 颜色(绿色), 总是);
	}
}

规则("Bastion Bot Enemy Search")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		是否是机器人(事件玩家) == 真;
		存活(事件玩家) == 真;
	}

	动作
	{
		事件玩家.temp = 已过滤的数组(所有存活玩家(对方队伍(所在队伍(事件玩家))), (在视线内(眼睛位置(事件玩家), 眼睛位置(当前数组元素), 屏障不会阻挡视线) == 真 || 在视线内(眼睛位置(事件玩家), 所选位置(当前数组元素),
			屏障不会阻挡视线) == 真) && 已重生(当前数组元素) && 当前数组元素.IsWinner == 假 && (所用英雄(当前数组元素) != 英雄(死神) || !正在使用技能 1(当前数组元素)) && (所用英雄(当前数组元素) != 英雄(
			莫伊拉) || !正在使用技能 1(当前数组元素)));
		等待(0.016, 无视条件);
		事件玩家.temp = 已排序的数组(事件玩家.temp, 全局.BastionBotTargetPreferWS == 0 ? 生命值(事件玩家) * 相距距离(事件玩家, 当前数组元素) : (
			全局.BastionBotTargetPreferWS == 1 ? 相距距离(事件玩家, 当前数组元素) : 生命值(当前数组元素)));
		等待(0.016, 无视条件);
		事件玩家.Enemy = 首个(事件玩家.temp);
		等待(随机实数(0.256, 0.512), 无视条件);
		如条件为“真”则循环;
	}
}

规则("Bastion Bot Fire")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		是否是机器人(事件玩家) == 真;
		存活(事件玩家) == 真;
		事件玩家.Enemy != 空;
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 假;
	}

	动作
	{
		开始按下按钮(事件玩家, 按钮(主要攻击模式));
		等待(0.256, 无视条件);
		如条件为“真”则循环;
	}
}

规则("Bastion Bot Stop Fire")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		是否是机器人(事件玩家) == 真;
		存活(事件玩家) == 真;
		事件玩家.Enemy == 空;
	}

	动作
	{
		停止按下按钮(事件玩家, 按钮(主要攻击模式));
	}
}

规则("Bastion Bot Aim Position")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		是否是机器人(事件玩家) == 真;
		存活(事件玩家) == 真;
		事件玩家.Enemy != 空;
	}

	动作
	{
		事件玩家.TempAimPosition = 矢量(X方向分量(眼睛位置(事件玩家.Enemy)), Y方向分量(所选位置(事件玩家.Enemy)) + (Y方向分量(眼睛位置(事件玩家.Enemy)) - Y方向分量(所选位置(事件玩家.Enemy)))
			/ 2, Z方向分量(眼睛位置(事件玩家.Enemy)));
		If(在视线内(眼睛位置(事件玩家), 事件玩家.TempAimPosition, 屏障不会阻挡视线) == 真);
			事件玩家.AimPosition = 事件玩家.TempAimPosition;
		Else;
			If(在视线内(眼睛位置(事件玩家), 眼睛位置(事件玩家.Enemy), 屏障不会阻挡视线) == 真);
				事件玩家.AimPosition = 眼睛位置(事件玩家.Enemy);
			Else;
				事件玩家.AimPosition = 所选位置(事件玩家.Enemy);
			End;
		End;
		等待(0.032, 无视条件);
		如条件为“真”则循环;
	}
}

规则("Bastion Bot Aim Position 2")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		是否是机器人(事件玩家) == 真;
		存活(事件玩家) == 真;
		事件玩家.Enemy == 空;
	}

	动作
	{
		事件玩家.EnemyUnSeen = 首个(已排序的数组(已过滤的数组(所有存活玩家(对方队伍(所在队伍(事件玩家))), 已重生(当前数组元素) && 事件玩家.IsWinner != 真), 相距距离(眼睛位置(事件玩家), 眼睛位置(当前数组元素))));
		根据条件跳过(事件玩家.EnemyUnSeen == 空, 1);
		事件玩家.AimPosition = 眼睛位置(事件玩家.EnemyUnSeen) + 矢量(随机实数(-1, 1), 随机实数(-1, 1), 随机实数(-1, 1));
		等待(随机实数(1, 4), 无视条件);
		如条件为“真”则循环;
	}
}

规则("Bastion Bot Aim Smoother")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		是否是机器人(事件玩家) == 真;
		存活(事件玩家) == 真;
		事件玩家.Enemy != 空;
	}

	动作
	{
		事件玩家.TurnSpeed = 矢量间夹角(面朝方向(事件玩家), 方向(眼睛位置(事件玩家), 眼睛位置(事件玩家.Enemy))) * 6;
		事件玩家.TurnSpeed += 速度(事件玩家.Enemy) * 10;
		等待(服务器负载平均值 / 1000, 无视条件);
		如条件为“真”则循环;
	}
}

规则("Bastion Bot Aim Smoother 2")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		是否是机器人(事件玩家) == 真;
		存活(事件玩家) == 真;
		事件玩家.Enemy == 空;
		矢量间夹角(面朝方向(事件玩家), 方向(眼睛位置(事件玩家), 所选位置(事件玩家.AimPosition))) >= 1;
	}

	动作
	{
		事件玩家.TurnSpeed = 矢量间夹角(面朝方向(事件玩家), 方向(眼睛位置(事件玩家), 所选位置(事件玩家.AimPosition))) * 7;
		等待(服务器负载峰值 / 1000, 当为“假”时中止);
		如条件为“真”则循环;
	}
}

规则("Bastion Bot Tactical Grenade Facing")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		是否是机器人(事件玩家) == 真;
		存活(事件玩家) == 真;
		事件玩家.Enemy != 空;
		技能冷却时间(事件玩家, 按钮(辅助攻击模式)) == 0;
	}

	动作
	{
		停止朝向(事件玩家);
		设置朝向(事件玩家, 方向(眼睛位置(事件玩家), 眼睛位置(事件玩家.Enemy) + 矢量(0, 随机实数(0.500, 2.500), 0)), 至地图);
	}
}

规则("Bastion Bot Fire Tactical Grenade")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		是否是机器人(事件玩家) == 真;
		存活(事件玩家) == 真;
		事件玩家.Enemy != 空;
		技能冷却时间(事件玩家, 按钮(辅助攻击模式)) == 0;
	}

	动作
	{
		等待(0.125, 当为“假”时中止);
		可用按钮(事件玩家, 按钮(辅助攻击模式));
		按下按键(事件玩家, 按钮(辅助攻击模式));
		如条件为“真”则循环;
	}
}

规则("Bastion Bot Start Facing")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		是否是机器人(事件玩家) == 真;
		存活(事件玩家) == 真;
		已重生(事件玩家) == 真;
		技能冷却时间(事件玩家, 按钮(辅助攻击模式)) > 0;
	}

	动作
	{
		停止朝向(事件玩家);
		开始朝向(事件玩家, 方向(眼睛位置(事件玩家), 事件玩家.AimPosition), 具有状态(事件玩家, 沉睡) ? 0 : 事件玩家.TurnSpeed, 至地图, 方向及角速率);
	}
}

规则("Bastion Bot NULL ENEMY")
{
	事件
	{
		持续 - 每名玩家;
		队伍2;
		堡垒;
	}

	条件
	{
		存活(事件玩家.Enemy) == 假;
	}

	动作
	{
		事件玩家.Enemy = 空;
		事件玩家.EnemyUnSeen = 空;
	}
}

规则("Spawn Dead Players (ENEMY)(RESPAWN)")
{
	事件
	{
		玩家阵亡;
		队伍2;
		全部;
	}

	条件
	{
		死亡(事件玩家) == 真;
	}

	动作
	{
		等待(0.048, 当为“假”时中止);
		复生(事件玩家);
		设置状态(事件玩家, 空, 无敌, 9999);
	}
}

规则("Spawn Dead Players (PLAYERS)(RESPAWN)")
{
	事件
	{
		玩家阵亡;
		队伍1;
		全部;
	}

	条件
	{
		死亡(事件玩家) == 真;
	}

	动作
	{
		关闭游戏预设复生模式(事件玩家);
		If(对任意为“真”(选择英雄的玩家(英雄(天使), 队伍1), !当前数组元素.IsWinner));
			等待(6, 当为“假”时中止);
		Else If(对任意为“真”(选择英雄的玩家(英雄(天使), 队伍1), 当前数组元素.IsWinner));
			等待(4, 当为“假”时中止);
		Else;
			等待(0.048, 当为“假”时中止);
		End;
		复生(事件玩家);
		调用子程序(SpawnAtAltLoc);
	}
}

规则("Show Bastions Position")
{
	事件
	{
		玩家造成最后一击;
		队伍2;
		全部;
	}

	动作
	{
		停止强制设置玩家轮廓(被攻击方.attacker, 被攻击方);
		等待(0.032, 无视条件);
		被攻击方.attacker = 攻击方;
		开始强制设置玩家轮廓(被攻击方.attacker, 被攻击方, 真, 颜色(红色), 总是);
	}
}

规则("Update Scoreboard")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		全局.ScoreboardArray = 已过滤的数组(随机数组(所有玩家(队伍1)), !当前数组元素.IsWinner);
		等待(30, 无视条件);
		循环;
	}
}

规则("SPAWN FIX (Blizz World)")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.IsWinner == 假;
		存活(事件玩家) == 真;
		已重生(事件玩家) == 真;
		(当前地图 == 地图(暴雪世界) || 当前地图 == 地图(圣诞节暴雪世界)) == 真;
	}

	动作
	{
		传送(事件玩家, 矢量(-166.920, 2.948, 97.847));
		设置朝向(事件玩家, 方向(眼睛位置(事件玩家), 眼睛位置(事件玩家.attacker)), 至地图);
	}
}

规则("Green outlines for winners")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		存活(事件玩家) == 真;
		事件玩家.IsWinner == 真;
	}

	动作
	{
		停止强制玩家选择英雄(事件玩家);
		开始强制设置玩家轮廓(事件玩家, 所有玩家(队伍1), 真, 颜色(绿色), 总是);
		隐藏姓名板(事件玩家, 所有玩家(队伍1));
		设置移动速度(事件玩家, 120);
		事件玩家.PlayerProgressVisibility = 所有玩家(队伍1);
		设置玩家可选的英雄(事件玩家, 全局.WinnerHeroesList);
	}
}

规则("force player hero")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.IsWinner == 假;
		所用英雄(事件玩家) != 事件玩家.IndieHeroList[事件玩家.CurrentHero];
	}

	动作
	{
		开始强制玩家选择英雄(事件玩家, 事件玩家.IndieHeroList[事件玩家.CurrentHero]);
		等待(0.250, 无视条件);
		预加载英雄(事件玩家, 数组分割(事件玩家.IndieHeroList, 事件玩家.CurrentHero + 1, 12));
		如条件为“真”则循环;
		小字体信息(已过滤的数组(所有玩家(队伍1), 当前数组元素 != 事件玩家), 自定义字符串("{0} is now {1}!", 事件玩家, 英雄图标字符串(所用英雄(事件玩家))));
	}
}

规则("Player reset button combo shortcut (BUTTONS)(Winners)")
{
	事件
	{
		持续 - 每名玩家;
		队伍1;
		全部;
	}

	条件
	{
		事件玩家.IsWinner == 真;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
	}

	动作
	{
		小字体信息(事件玩家, 自定义字符串("Teleporting to spawn. Continue Holding!"));
		等待(3, 当为“假”时中止);
		复生(事件玩家);
		调用子程序(SpawnAtAltLoc);
	}
}